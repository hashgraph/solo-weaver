# SPDX-License-Identifier: Apache-2.0

version: 3
silent: false
output: prefixed
vars:
  OS: [ linux ]
  ARCH: [ amd64, arm64 ]
  GO_VERSION: 1.25.2
  LDFLAGS: "-w -s"
  LDFLAGS_RELEASE: "-w -s -X 'github.com/hashgraph/solo-weaver/internal/version.buildMode=release'"
  # VM configuration
  VM_OS_TYPE: '{{.VM_OS_TYPE | default "debian"}}'  # Options: debian, ubuntu
  VM_NAME: "solo-weaver-{{.VM_OS_TYPE}}"
  VM_GOLDEN_NAME: "solo-weaver-{{.VM_OS_TYPE}}-golden"
  # Set this to the actual URL or local path of your golden image (e.g., "https://storage.example.com/golden-image.utm" or "/path/to/golden-image.utm")
  # For Debian: Set your Debian golden image URL
  # For Ubuntu: Set your Ubuntu 22.04 golden image URL
  VM_GOLDEN_IMAGE_URL_DEBIAN: '{{.VM_GOLDEN_IMAGE_URL_DEBIAN | default "https://storage.googleapis.com/solo-weaver/solo-weaver-debian-golden.utm.tar.gz" }}'
  VM_GOLDEN_IMAGE_URL_UBUNTU: '{{.VM_GOLDEN_IMAGE_URL_UBUNTU | default "https://storage.googleapis.com/solo-weaver/solo-weaver-ubuntu-golden.utm.tar.gz" }}'
  VM_USER: "provisioner"
  SSH_PRIVATE_KEY: "{{.PWD}}/.ssh/id_rsa_vm"
  SSH_PUBLIC_KEY: "{{.SSH_PRIVATE_KEY}}.pub"
  UTM_VMS_DIR: "{{.HOME}}/Library/Containers/com.utmapp.UTM/Data/Documents"
  GET_VM_IP: |
    get_vm_ip() {
    utmctl ip-address "{{.VM_NAME}}" 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1
    }

tasks:
  clean:
    cmds:
      - "rm -rf bin"
      - "rm -f unit-test-report.md"
      - "mkdir -p bin"
      - "go clean -cache -testcache"
  
  vendor:
    cmds:
      - "go mod vendor"
  
  lint:
    cmds:
      - "go fmt -x ./..."
  
  lint:check:
    cmds:
      - "R=$(go fmt ./...) && if [[ -n \"$R\" ]]; then echo \"The following files require formatting:\"; echo \"$R\"; exit 1; fi"
  
  license:check:
    desc: "Check if all source files have SPDX license headers"
    dir: scripts
    cmds:
      - "./license-header.sh check"
  
  license:add:
    desc: "Add SPDX license headers to source files that are missing them"
    dir: scripts
    cmds:
      - "./license-header.sh add"
  
  license:
    desc: "Alias for license:add - Add SPDX license headers to source files"
    cmds:
      - task: license:add
  
  build:
    deps:
      - "vendor"
    cmds:
      - task: "clean"
      - task: "generate"
      - task: "build:weaver:all"
    sources:
      - "**/*.go"
    generates:
      - "bin/weaver-linux-*"
      - "bin/weaver-darwin-*"

  build:release:
    desc: "Build all binaries for release (production mode)"
    deps:
      - "vendor"
    cmds:
      - task: "clean"
      - task: "generate"
      - task: "build:weaver:release:all"
    sources:
      - "**/*.go"
    generates:
      - "bin/weaver-linux-*"
      - "bin/weaver-darwin-*"

  hash:
    deps:
      - "build:release"
    cmds:
      - task: "hash:weaver:all"
    sources:
      - "bin/weaver-linux-*"
      - "bin/weaver-darwin-*"
    generates:
      - "bin/*.sha256"

  sign:
    deps:
      - "build:release"
    cmds:
      - task: "sign:weaver:all"

  build:image:
    deps:
      - task: "hash"
    cmds:
      - "docker build -t solo-weaver ."
  
  generate:
    cmds:
      - "go generate ./..."
  
  build:weaver:all:
    desc: "Build the binary for all configured operating systems and architectures"
    cmds:
      - task: build:weaver:all:os
  
  build:weaver:all:os:
    internal: true
    desc: "Build the binary for all configured operating systems"
    cmds:
      - for:
          var: OS
        task: build:weaver:all:arch
        vars:
          GOOS: "{{.ITEM}}"
  
  build:weaver:all:arch:
    internal: true
    desc: "Build the binary for all configured architectures"
    cmds:
      - for:
          var: ARCH
        task: build:weaver
        vars:
          GOOS: "{{.GOOS}}"
          GOARCH: "{{.ITEM}}"
  
  build:weaver:
    desc: "Build the binary for the specified operating system and architecture (dev mode)"
    env:
      GOOS: "{{coalesce .GOOS OS}}"
      GOARCH: "{{coalesce .GOARCH ARCH}}"
    cmds:
      - cmd: go build -ldflags='{{.LDFLAGS}}' -trimpath -o bin/weaver-{{coalesce .GOOS OS}}-{{coalesce .GOARCH ARCH}} ./cmd/weaver
      - cmd: chmod +x bin/weaver-{{coalesce .GOOS OS}}-{{coalesce .GOARCH ARCH}}
  
  build:weaver:release:
    desc: "Build the binary for release (production mode - disables dev-only features)"
    env:
      GOOS: "{{coalesce .GOOS OS}}"
      GOARCH: "{{coalesce .GOARCH ARCH}}"
    cmds:
      - cmd: go build -ldflags='{{.LDFLAGS_RELEASE}}' -trimpath -o bin/weaver-{{coalesce .GOOS OS}}-{{coalesce .GOARCH ARCH}} ./cmd/weaver
      - cmd: chmod +x bin/weaver-{{coalesce .GOOS OS}}-{{coalesce .GOARCH ARCH}}

  build:weaver:release:all:
    desc: "Build release binaries for all configured operating systems and architectures"
    cmds:
      - task: build:weaver:release:all:os

  build:weaver:release:all:os:
    internal: true
    cmds:
      - for:
          var: OS
        task: build:weaver:release:all:arch
        vars:
          GOOS: "{{.ITEM}}"

  build:weaver:release:all:arch:
    internal: true
    cmds:
      - for:
          var: ARCH
        task: build:weaver:release
        vars:
          GOOS: "{{.GOOS}}"
          GOARCH: "{{.ITEM}}"

  hash:weaver:all:
    desc: "Hash the binary binaries for all configured operating systems and architectures"
    cmds:
      - task: hash:weaver:all:os
  
  hash:weaver:all:os:
    internal: true
    desc: "Hash the binary binaries for all configured operating systems"
    cmds:
      - for:
          var: OS
        task: hash:weaver:all:arch
        vars:
          GOOS: "{{.ITEM}}"
  
  hash:weaver:all:arch:
    internal: true
    desc: "Hash the binary binaries for all configured architectures"
    cmds:
      - for:
          var: ARCH
        task: hash:weaver
        vars:
          GOOS: "{{.GOOS}}"
          GOARCH: "{{.ITEM}}"
  
  hash:weaver:
    internal: true
    desc: "Hash the binary binaries for the specified operating system and architecture"
    dir: bin
    cmds:
      - cmd: sha256sum weaver-{{.GOOS}}-{{.GOARCH}} > weaver-{{.GOOS}}-{{.GOARCH}}.sha256
  
  sign:weaver:all:
    desc: "Sign the binary binaries for all configured operating systems and architectures"
    cmds:
      - task: sign:weaver:all:os
  
  sign:weaver:all:os:
    internal: true
    desc: "Sign the binary binaries for all configured operating systems"
    cmds:
      - for:
          var: OS
        task: sign:weaver:all:arch
        vars:
          GOOS: "{{.ITEM}}"
  
  sign:weaver:all:arch:
    internal: true
    desc: "Sign the binary binaries for all configured architectures"
    cmds:
      - for:
          var: ARCH
        task: sign:weaver
        vars:
          GOOS: "{{.GOOS}}"
          GOARCH: "{{.ITEM}}"
  
  sign:weaver:
    internal: true
    desc: "Sign the binary binaries for the specified operating system and architecture"
    env:
      GOOS: "{{coalesce .GOOS OS}}"
      GOARCH: "{{coalesce .GOARCH ARCH}}"
    cmds:
      - task: hash:weaver
        vars:
          GOOS: "{{.GOOS}}"
          GOARCH: "{{.GOARCH}}"
      - cmd: gpg --batch --yes --armor --output bin/weaver-{{.GOOS}}-{{.GOARCH}}.sha256.asc --detach-sign bin/weaver-{{.GOOS}}-{{.GOARCH}}.sha256
      - cmd: gpg --batch --yes --armor --output bin/weaver-{{.GOOS}}-{{.GOARCH}}.asc --detach-sign bin/weaver-{{.GOOS}}-{{.GOARCH}}
  
  test:
    cmds:
      - task: "test:unit"
  
  test:unit:
    deps:
      - "generate"
      - "mocks"
    cmds:
      # Using go-testreport v0.3.2
      - "go install github.com/becheran/go-testreport@90efc1ce13c872f23d6bc8a069527c26288b8f9c"
      - "go test -race -cover -json -tags='!integration' ./internal/... ./pkg/... ./cmd/... | go-testreport -output unit-test-report.md -vars 'Title:Unit Test Report'"
  
  test:unit:verbose:
    desc: "Run unit tests with verbose console output"
    deps:
      - "generate"
      - "mocks"
    cmds:
      - "go test -v -race -cover -tags='!integration' ./internal/... ./pkg/... ./cmd/..."
  
  test:integration:verbose:
    desc: "Run integration tests with verbose console output. Use TEST_NAME to run a specific test, e.g., task test:integration:verbose TEST_NAME='^Test_StepKubeadm_Fresh_Integration$'"
    cmds:
      - |
        set +e  # Don't exit on error
        start=$(date +%s)
        
        # run tests
        {{if .TEST_NAME}}
        echo "Running integration test '{{.TEST_NAME}}'..."
        go test -p 1 -v -tags='integration' -run {{.TEST_NAME}} ./internal/... ./pkg/... ./cmd/... -timeout 60m
        {{else}}
        go test -p 1 -v -race -cover -tags='integration' ./internal/... ./pkg/... ./cmd/... -timeout 60m
        {{end}}
        status=$?
        
        end=$(date +%s)
        elapsed=$(( end - start ))
        
        hrs=$(( elapsed / 3600 ))
        mins=$(( (elapsed % 3600) / 60 ))
        secs=$(( elapsed % 60 ))
        
        {{if .TEST_NAME}}
        printf "\n=== Integration test '{{.TEST_NAME}}' finished in %02d:%02d:%02d (status %d) ===\n" \
          "$hrs" "$mins" "$secs" "$status"
        {{else}}
        printf "\n=== Integration tests finished in %02d:%02d:%02d (status %d) ===\n" \
          "$hrs" "$mins" "$secs" "$status"
        {{end}}
        
        exit $status
  
  test:coverage:
    desc: "Run test coverage analysis. Use TEST_PATHS and TEST_REGEX to filter tests. For example: task test:coverage TEST_PATHS=./pkg/software/..."
    vars:
      TEST_PATHS: '{{.TEST_PATHS | default "./internal/... ./pkg/... ./cmd/..."}}'
      TEST_REGEX: '{{.TEST_REGEX | default "."}}'
    cmds:
      - "go install github.com/vladopajic/go-test-coverage/v2@7003e902e787e60375e1ce3ae5b85b19313dbff2"
      - "go test -p 1 -tags='integration' -race -cover -json {{.TEST_PATHS}} -run '{{.TEST_REGEX}}' -coverprofile=./cover.out -covermode=atomic -coverpkg=./... -timeout 60m"
      - "go-test-coverage --config=./.testcoverage.yml"
  
  test:integration:
    desc: "Run integration tests (includes cluster_test.go)"
    deps:
      - "generate"
    cmds:
      # Using go-testreport v0.3.2
      - "go install github.com/becheran/go-testreport@90efc1ce13c872f23d6bc8a069527c26288b8f9c"
      - "go test -p 1 -race -cover -json -tags='integration' ./internal/... ./pkg/... ./cmd/... -timeout 60m > integration-test.json"
      - "go-testreport -input integration-test.json -output integration-test-report.md -vars 'Title:Integration Test Report'"
  
  run:
    deps:
      - "run:weaver"
  
  run:weaver:
    deps:
      - "build"
    cmds:
      - "bin/weaver-{{OS}}-{{ARCH}}{{exeExt}} {{.CLI_ARGS}}"
  
  run:weaver:skipdl:
    deps:
      - "build"
    env:
      _LOG_LEVEL: "Debug"
    cmds:
      - "bin/weaver-{{OS}}-{{ARCH}}{{exeExt}} {{.CLI_ARGS}}"
  
  install:go:
    deps:
      - "install:go:linux"
  
  install:go:linux:
    internal: true
    status:
      - "command -v go"
      - "command -v dlv"
    platforms:
      - "linux/amd64"
      - "linux/arm64"
    cmds:
      - "curl -sSLO https://go.dev/dl/go{{.GO_VERSION}}.{{OS}}-{{ARCH}}.tar.gz"
      - "sudo mkdir -p /usr/local/go"
      - "sudo tar -C /usr/local -xzf go{{.GO_VERSION}}.{{OS}}-{{ARCH}}.tar.gz"
      - "rm -f go{{.GO_VERSION}}.{{OS}}-{{ARCH}}.tar.gz"
      - "echo 'PATH=\"${PATH}:/usr/local/go/bin:$HOME/go/bin\"' | sudo tee /etc/profile.d/go.sh >/dev/null 2>&1"
      - "source /etc/profile.d/go.sh"
      - "source /etc/profile.d/go.sh && go install github.com/go-delve/delve/cmd/dlv@latest"
      # Set the Go toolchain to auto-upgrade to the latest version due to https://github.com/golang/go/issues/75031
      - "/usr/local/go/bin/go env -w GOTOOLCHAIN=go1.25.2+auto"
      - "sudo /usr/local/go/bin/go env -w GOTOOLCHAIN=go1.25.2+auto"
    generates:
      - "/usr/local/go/**"
  
  mocks:
    cmds:
      - go install github.com/golang/mock/mockgen@v1.6.0
      # Generate mocks in the package it belongs. Note these generated mock files are not checked in.
      - mockgen -source=pkg/security/principal/interface.go -self_package github.com/hashgraph/solo-weaver/pkg/security/principal -package principal > pkg/security/principal/mocks_generated.go
      - mockgen -source=pkg/fsx/interface.go -self_package github.com/hashgraph/solo-weaver/pkg/fsx -package fsx > pkg/fsx/mocks_generated.go
      - mockgen -source=pkg/software/interface.go -self_package github.com/hashgraph/solo-weaver/pkg/software -package software> pkg/software/mocks_generated.go
      - mockgen -source=pkg/kernel/interface.go -self_package github.com/hashgraph/solo-weaver/pkg/kernel -package kernel > pkg/kernel/mocks_generated.go
  
  # Remote debug tasks for Docker container debugging
  debug:container:
    desc: "Setup debug environment and show available debug commands"
    deps:
      - "debug:container:setup"
    cmds:
      - |
        echo "ğŸ› Debug environment ready!"
        echo ""
        echo "Available debug commands:"
        echo "  task debug:container:test -- [package]   # Debug tests (package required)"
        echo "  task debug:container:app -- [args...]    # Debug weaver application"
        echo "  task debug:container:stop                # Stop debug container"
        echo ""
  
  debug:container:setup:
    desc: "Setup Docker container for remote debugging"
    dir: build
    cmds:
      - "./debug-setup.sh"
  
  debug:container:test:
    desc: "Start remote test debug server in Docker container (specify package with -- ./pkg/name)"
    deps:
      - "debug:container:setup"
    dir: build
    cmds:
      - "./debug-run.sh test {{.CLI_ARGS}}"
  
  debug:container:app:
    desc: "Start remote application debug server in Docker container (pass args with -- after command)"
    deps:
      - "debug:container:setup"
    dir: build
    cmds:
      - "./debug-run.sh app {{.CLI_ARGS}}"
  
  debug:container:stop:
    desc: "Stop remote debug container"
    cmds:
      - "docker stop solo-weaver-debug 2>/dev/null || true"
  
  # VM Debugging Tasks
  vm:debug:
    desc: "Show available VM debug commands"
    cmds:
      - |
        echo "ğŸ› VM Debug environment ready!"
        echo ""
        echo "Available debug commands:"
        echo "  task debug:vm:test -- [package]   # Debug tests on the VM (package required)"
        echo "  task debug:vm:app -- [args...]    # Debug weaver application on the VM"
        echo ""
  
  vm:debug:test:
    desc: "Start remote test debug server on the VM (specify package with -- ./pkg/name)"
    dir: scripts
    deps:
      - "vm:start"
    cmds:
      - "./debug-vm-run.sh test {{.CLI_ARGS}}"
  
  vm:debug:app:
    desc: "Start remote application debug server on the VM (pass args with -- after command)"
    dir: scripts
    deps:
      - "vm:start"
    cmds:
      - "./debug-vm-run.sh app {{.CLI_ARGS}}"
  
  vm:targets:
    desc: "Show available VM OS targets and create VMs for specific OS types"
    cmds:
      - |
        echo "ğŸ¯ VM OS Targets"
        echo "================"
        echo ""
        echo "Available OS types:"
        echo "  â€¢ debian  - Debian Linux"
        echo "  â€¢ ubuntu  - Ubuntu 22.04"
        echo ""
        echo "Current VM_OS_TYPE: {{.VM_OS_TYPE}}"
        echo "Current VM_NAME: {{.VM_NAME}}"
        echo "Current VM_GOLDEN_NAME: {{.VM_GOLDEN_NAME}}"
        echo ""
        echo "Usage examples:"
        echo "  task vm:setup VM_OS_TYPE=debian      # Setup Debian VM"
        echo "  task vm:setup VM_OS_TYPE=ubuntu      # Setup Ubuntu 22.04 VM"
        echo "  task vm:start VM_OS_TYPE=debian      # Start Debian VM"
        echo "  task vm:start VM_OS_TYPE=ubuntu      # Start Ubuntu VM"
        echo "  task vm:reset VM_OS_TYPE=ubuntu      # Reset Ubuntu VM"
        echo ""
        echo "You can also set VM_OS_TYPE in your environment:"
        echo "  export VM_OS_TYPE=ubuntu"
        echo "  task vm:start"
        echo ""
        echo "To configure golden image URLs per OS type, set:"
        echo "  VM_GOLDEN_IMAGE_URL_DEBIAN=<url>"
        echo "  VM_GOLDEN_IMAGE_URL_UBUNTU=<url>"
  
  vm:ip:
    cmds:
      - "{{.GET_VM_IP}} echo $(get_vm_ip)"
  
  # VM Management Tasks
  vm:install:
    desc: "Install UTM and rsync if not already installed"
    cmds:
      - |
        if ! command -v brew >/dev/null 2>&1; then
          echo "Error: Homebrew is required to install UTM and rsync"
          echo "Please install Homebrew first: https://brew.sh"
          exit 1
        fi
        
        if ! command -v utmctl >/dev/null 2>&1; then
          echo "Installing UTM via Homebrew..."
          brew install --cask utm
        else
          echo "UTM is already installed"
        fi
        
        if ! command -v rsync >/dev/null 2>&1; then
          echo "Installing rsync via Homebrew..."
          brew install rsync
        else
          echo "rsync is already installed"
        fi
  
  vm:setup:
    desc: "Download and setup the pre-built golden VM image"
    deps:
      - vm:install
    cmds:
      - task: vm:download:golden
  
  vm:download:golden:
    desc: "Download pre-built golden VM image from URL. Use FORCE to force re-downloading, e.g., task vm:download:golden FORCE=true"
    env:
      FORCE: '{{.FORCE | default "false"}}'
    cmds:
      - |
        echo "Checking if golden VM already exists..."
        echo "VM OS Type: {{.VM_OS_TYPE}}"
        echo "VM Golden Name: {{.VM_GOLDEN_NAME}}"
        echo "UTM VMs Directory: {{.UTM_VMS_DIR}}"
        echo 'Force Download: {{ eq .FORCE "true" }}'
        
        if [ "{{.FORCE}}" = "true" ]; then
         echo "Force flag is set, re-downloading golden VM image..."
        else
          # Check if the golden VM already exists
          if utmctl status "{{.VM_GOLDEN_NAME}}" >/dev/null 2>&1; then
            echo "âœ“ Golden VM already exists, skipping download."
            exit 0
          fi
        
          # if the .utm file exists in UTM_VMS_DIR, skip download
          echo "Checking UTM VMs directory for existing golden VM...: {{.UTM_VMS_DIR}}/{{.VM_GOLDEN_NAME}}.utm"
          if [ -d "{{.UTM_VMS_DIR}}/{{.VM_GOLDEN_NAME}}.utm" ] || [ -f "{{.UTM_VMS_DIR}}/{{.VM_GOLDEN_NAME}}.utm" ]; then
            echo "âœ“ Golden VM already exists in UTM directory: {{.UTM_VMS_DIR}}/{{.VM_GOLDEN_NAME}}.utm"
            echo "ğŸ‘‰ Please restart UTM to reload VMs and set up the shared solo-weaver directory ('open -a UTM')."
            exit 1 # non zero would stop further steps
          else
            echo "âœ“ No existing golden VM found, proceeding to download."
          fi
        fi
        
        # Determine which golden image URL to use based on OS type
        GOLDEN_IMAGE_URL=""
        case "{{.VM_OS_TYPE}}" in
          debian)
            GOLDEN_IMAGE_URL="{{.VM_GOLDEN_IMAGE_URL_DEBIAN}}"
            ;;
          ubuntu)
            GOLDEN_IMAGE_URL="{{.VM_GOLDEN_IMAGE_URL_UBUNTU}}"
            ;;
          *)
            echo "âŒ Unknown VM_OS_TYPE: {{.VM_OS_TYPE}}"
            echo "Supported types: debian, ubuntu"
            exit 1
            ;;
        esac
        
        if [ -z "$GOLDEN_IMAGE_URL" ]; then
          echo "âŒ No golden image URL configured for {{.VM_OS_TYPE}}"
          echo "Please set VM_GOLDEN_IMAGE_URL_{{.VM_OS_TYPE | upper}} or VM_GOLDEN_IMAGE_URL"
          echo "Example: VM_GOLDEN_IMAGE_URL_UBUNTU=https://example.com/ubuntu-22.04.utm"
          exit 1
        fi
        
        echo "Golden VM not found, downloading {{.VM_OS_TYPE}} image from $GOLDEN_IMAGE_URL..."
        
        # Create temporary directory for download
        TEMP_DIR=$(mktemp -d)
        
        # Clean up
        cleanup() { rm -rf "$TEMP_DIR"; }
        trap cleanup EXIT
        
        echo "Downloading to temporary directory: $TEMP_DIR"
        
        TMP_FILE="$TEMP_DIR/download.tar.gz"
        
        # Download the golden image
        if ! curl -fL -o "$TMP_FILE" "$GOLDEN_IMAGE_URL"; then
          echo "âŒ Failed to download the golden VM image from $GOLDEN_IMAGE_URL"
          echo "Please check the URL and try again or download the image manually and import it manually."
          rm -rf "$TEMP_DIR"
          exit 0
        fi
        
        tar -xzf "$TMP_FILE" -C "$TEMP_DIR"
        UTM_PATH=$(find "$TEMP_DIR" -maxdepth 3 \( -type d -name '*.utm' -o -type f -name '*.utm' \) -print -quit || true)
        if [ -z "$UTM_PATH" ]; then
          echo "âŒ No .utm entry found inside $GOLDEN_IMAGE_URL"
          exit 1
        fi
        
        # Normalize to a known path for the rest of the script
        mv "$UTM_PATH" "$TEMP_DIR/golden-image.utm"
        echo "âœ“ Downloaded and prepared golden image at $TEMP_DIR/golden-image.utm"
        
        # Copy the VM to UTM directory and rename
        cp -r "$TEMP_DIR/golden-image.utm" "{{.UTM_VMS_DIR}}/{{.VM_GOLDEN_NAME}}.utm"
        
        echo "âœ“ Golden VM downloaded successfully and placed in UTM directory: {{.UTM_VMS_DIR}}/{{.VM_GOLDEN_NAME}}.utm"
        echo "ğŸ‘‰ Please restart UTM to reload VMs and set up the shared solo-weaver directory ('open -a UTM')."
        exit 1 # non zero would stop further steps
  
  vm:reset:
    desc: "Clone the golden VM to create a working instance with passwordless SSH"
    deps:
      - vm:setup
      - proxy:start
    cmds:
      - |
        # Generate SSH key if it doesn't exist
        if [ ! -f "{{.SSH_PRIVATE_KEY}}" ]; then
          echo "Generating SSH key for VM access..."
          mkdir -p .ssh
          ssh-keygen -t rsa -b 2048 -f {{.SSH_PRIVATE_KEY}} -N ""
          echo "âœ“ SSH key generated at {{.SSH_PRIVATE_KEY}}"
        fi
        
        echo "Cloning golden VM to working instance..."
        
        # Check if golden VM exists
        if ! utmctl status "{{.VM_GOLDEN_NAME}}" >/dev/null 2>&1; then
          echo "Error: Golden VM '{{.VM_GOLDEN_NAME}}' not found. Run 'task vm:setup' first."
          echo "If you have downloaded the golden VM image manually, please import it manually."
          exit 1
        fi
        
        # Stop the golden VM if it's running (required for cloning)
        echo "Ensuring golden VM is stopped for cloning..."
        utmctl stop "{{.VM_GOLDEN_NAME}}" 2>/dev/null || true
        sleep 2
        
        # Stop and delete existing working VM if it exists
        if utmctl status "{{.VM_NAME}}" >/dev/null 2>&1; then
          echo "Stopping and removing existing working VM..."
          utmctl stop "{{.VM_NAME}}" 2>/dev/null || true
          sleep 2
          utmctl delete "{{.VM_NAME}}" 2>/dev/null || true
          sleep 1
        fi
        
        # Clone the golden VM
        echo "Cloning '{{.VM_GOLDEN_NAME}}' to '{{.VM_NAME}}'..."
        utmctl clone "{{.VM_GOLDEN_NAME}}" --name "{{.VM_NAME}}"
        
        echo "âœ“ VM cloned. Now starting it for initial configuration..."
      - task: vm:start
      - task: vm:configure:ssh
      - task: proxy:install-ca-cert
      - task: vm:observability:start
      - cmd: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… VM reset complete with full development environment!"
          echo ""
          echo "Configured:"
          echo "  âœ… SSH access with passwordless login"
          echo "  âœ… MITM proxy with CA certificate"
          echo "  âœ… Docker installed and configured"
          echo "  âœ… Observability stack (Prometheus, Loki, Grafana)"
          echo ""
          echo "Ready for Block Node deployment:"
          echo "  task vm:ssh"
          echo "  sudo weaver block node install -p local -c /mnt/solo-weaver/test/config/config.yaml"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  vm:start:
    desc: "Start the working VM instance"
    deps:
      - vm:ensure-exists
    cmds:
      - utmctl start --hide "{{.VM_NAME}}"
      - |
        echo "Waiting for VM to boot (checking every 5 seconds)..."
        
        # Poll for VM to be ready with timeout
        MAX_ATTEMPTS=24  # 24 * 5 seconds = 2 minutes max wait
        ATTEMPT=0
        
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          ATTEMPT=$((ATTEMPT + 1))
        
          # Check if VM is running
          if utmctl status "{{.VM_NAME}}" >/dev/null 2>&1; then
            echo "âœ“ VM is running, checking if network is ready..."
        
            VM_IP=$({{.GET_VM_IP}} get_vm_ip)
            if [ -n "$VM_IP" ]; then
              echo "âœ“ VM started successfully and network is ready at $VM_IP!"
              break
            else
              echo "VM is running but network not ready yet (attempt $ATTEMPT/$MAX_ATTEMPTS)..."
            fi
          else
            echo "VM is starting... (attempt $ATTEMPT/$MAX_ATTEMPTS)"
          fi
        
          if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
            sleep 5
          fi
        done
        
        # Final check
        if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
          echo "âš ï¸  VM may not be fully ready after 2 minutes, but continuing..."
        fi
      - task: vm:ssh:port-forward
  
  vm:ssh:port-forward:
    desc: "Forward port 2222 to 22 on the VM for debugging purposes"
    internal: true
    cmds:
      - |
        # Check if VM is configured with SSH (check if SSH key works)
        VM_IP=$({{.GET_VM_IP}} get_vm_ip)
        if ! ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o PasswordAuthentication=no -o PubkeyAuthentication=yes {{.VM_USER}}@$VM_IP "echo 'SSH test successful'" >/dev/null 2>&1; then
          echo "SSH key authentication failed. VM may not be configured yet."
          exit 0
        fi
        
        echo "Setting up SSH port forwarding..."
        echo "Checking if port 2222 is available..."
        if command lsof -t -i :2222 >/dev/null 2>&1; then
          echo "Port 2222 is in use, killing existing SSH connection..."
          lsof -nP -t -iTCP:2222 -sTCP:LISTEN | xargs -r kill || true
          sleep 1
        else
          echo "âœ“ Port 2222 is available"
        fi
        # Forward port 2222 to 22 on the VM
        ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR -fN -L 2222:127.0.0.1:22 {{.VM_USER}}@$VM_IP
        echo "âœ“ SSH port forwarding established on localhost:2222 for debugging purposes"
  
  vm:configure:
    internal: true
    desc: "Configure the VM with SSH, sudo, and mounts (full configuration)"
    cmds:
      - task: vm:configure:ssh
      - task: vm:configure:tools
  
  vm:configure:ssh:
    internal: true
    desc: "Configure SSH access, sudo, and mounts (runs before proxy setup)"
    cmds:
      - |
        echo "Configuring SSH access for user {{.VM_USER}}..."
        PUBLIC_KEY=$(cat {{.SSH_PUBLIC_KEY}})
        
        echo "DEBUG: Public key length: ${#PUBLIC_KEY} characters"
        echo "DEBUG: Configuring SSH keys via utmctl exec..."
        
        # Configure SSH for the provisioner user using utmctl exec
        # Create directory structure
        echo "Creating .ssh directory..."
        utmctl exec "{{.VM_NAME}}" --cmd /bin/bash -c "mkdir -p /home/{{.VM_USER}}/.ssh && chmod 700 /home/{{.VM_USER}}/.ssh"
        
        # Write the key using printf which handles special characters well
        echo "Writing authorized_keys file..."
        utmctl exec "{{.VM_NAME}}" --cmd /bin/bash -c "printf '%s\\n' \"$PUBLIC_KEY\" > /home/{{.VM_USER}}/.ssh/authorized_keys && chmod 600 /home/{{.VM_USER}}/.ssh/authorized_keys && chown -R {{.VM_USER}}:{{.VM_USER}} /home/{{.VM_USER}}/.ssh"
        
        echo "âœ“ SSH key configured for user {{.VM_USER}}"
        
        # Ensure SSH service is installed and running
        echo "Ensuring SSH server is installed..."
        utmctl exec "{{.VM_NAME}}" --cmd /bin/bash -c "command -v sshd >/dev/null 2>&1 || apt-get update -qq && apt-get install -y openssh-server" 2>&1 || echo "SSH server check completed"
        
        echo "Configuring passwordless sudo for {{.VM_USER}} via utmctl (as root)..."
        utmctl exec "{{.VM_NAME}}" --cmd /bin/bash -c "echo '{{.VM_USER}} ALL=(ALL) NOPASSWD: ALL' > /etc/sudoers.d/{{.VM_USER}} && chmod 440 /etc/sudoers.d/{{.VM_USER}} && echo 'âœ“ Passwordless sudo configured for {{.VM_USER}}'" 2>&1
        
        echo "Ensuring SSH service is enabled and running..."
        utmctl exec "{{.VM_NAME}}" --cmd /bin/bash -c "systemctl enable ssh 2>/dev/null || systemctl enable sshd 2>/dev/null || true" 2>&1
        utmctl exec "{{.VM_NAME}}" --cmd /bin/bash -c "systemctl start ssh 2>/dev/null || systemctl start sshd 2>/dev/null || service ssh start 2>/dev/null || service sshd start 2>/dev/null || /etc/init.d/ssh start 2>/dev/null || true" 2>&1
      
      - |
        echo "Waiting for SSH service to be ready..."
        VM_IP=$({{.GET_VM_IP}} get_vm_ip)
        
        if [ -z "$VM_IP" ]; then
          echo "âŒ Could not get VM IP address. VM may not have network configured."
          exit 1
        fi
        
        echo "VM IP: $VM_IP"
        echo "Attempting SSH connection to {{.VM_USER}}@$VM_IP..."
        
        MAX_SSH_ATTEMPTS=10
        SSH_ATTEMPT=0
        while [ $SSH_ATTEMPT -lt $MAX_SSH_ATTEMPTS ]; do
          SSH_ATTEMPT=$((SSH_ATTEMPT + 1))
        
          echo -n "Attempt $SSH_ATTEMPT/$MAX_SSH_ATTEMPTS: "
        
          if ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=3 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o BatchMode=yes {{.VM_USER}}@$VM_IP "echo 'SSH ready'" >/dev/null 2>&1; then
            echo "âœ“ SSH is ready!"
            break
          fi
        
          echo "Connection failed, retrying..."
        
          sleep 3
        done
        
        if [ $SSH_ATTEMPT -eq $MAX_SSH_ATTEMPTS ]; then
          echo ""
          echo "âŒ SSH is not responding after $MAX_SSH_ATTEMPTS attempts"
          echo ""
          exit 1
        fi
      - |
        echo "Configuring SSH for root user and system settings..."
        VM_IP=$({{.GET_VM_IP}} get_vm_ip)
        PUBLIC_KEY=$(cat {{.SSH_PUBLIC_KEY}})
        
        # Now use SSH as provisioner with sudo to configure root and system
        # Passwordless sudo was already configured via utmctl exec
        ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{.VM_USER}}@$VM_IP "
          set -e
        
          echo 'Verifying sudo is available...'
          if ! command -v sudo >/dev/null 2>&1; then
            echo 'âŒ sudo not found. Cannot proceed with configuration.'
            exit 1
          fi
        
          echo 'Verifying passwordless sudo is configured...'
          sudo -n true 2>/dev/null || {
            echo 'âš ï¸  Passwordless sudo not working, but continuing...'
          }
        
          echo 'Creating weaver user and group with ID 2500...'
          if ! getent group weaver >/dev/null 2>&1; then
            sudo groupadd -g 2500 weaver
            echo 'âœ“ Created weaver group with GID 2500'
          else
            echo 'weaver group already exists'
          fi
        
          if ! id -u weaver >/dev/null 2>&1; then
            sudo useradd -u 2500 -g 2500 -m -s /bin/bash weaver
            echo 'âœ“ Created weaver user with UID 2500'
          else
            echo 'weaver user already exists'
          fi
        
          echo 'Configuring SSH key for root user...'
          sudo mkdir -p /root/.ssh
          sudo chmod 700 /root/.ssh
          echo \"$PUBLIC_KEY\" | sudo tee /root/.ssh/authorized_keys >/dev/null
          sudo chmod 600 /root/.ssh/authorized_keys
          echo 'âœ“ SSH key configured for user root'
        
          echo 'Configuring SSH daemon to allow root login with keys...'
          sudo sed -i 's/#PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config
          sudo sed -i 's/PermitRootLogin no/PermitRootLogin yes/' /etc/ssh/sshd_config
          sudo sed -i 's/#PubkeyAuthentication.*/PubkeyAuthentication yes/' /etc/ssh/sshd_config
          sudo sed -i 's/#AuthorizedKeysFile.*/AuthorizedKeysFile .ssh\/authorized_keys/' /etc/ssh/sshd_config
          sudo systemctl restart sshd || sudo systemctl restart ssh
          echo 'âœ“ SSH daemon configured for root login with keys'
        
          echo 'Mounting shared directory...'
          sudo mkdir -p /mnt/solo-weaver
          if ! grep -q '/mnt/solo-weaver' /etc/fstab; then
            echo 'share   /mnt/solo-weaver   9p  trans=virtio,version=9p2000.L,rw,nofail 0   0' | sudo tee -a /etc/fstab >/dev/null
          fi
          sudo mount -a || true
        
          # Try to set ownership and permissions to the VM user (best effort)
        
          echo "âœ“ Shared directory mounted at /mnt/solo-weaver"
        "
  
  vm:configure:tools:
    internal: true
    desc: "Install development tools (Git, Task, Go, Delve) - runs after proxy tunnels are set up"
    cmds:
      - |
        VM_IP=$({{.GET_VM_IP}} get_vm_ip)
        echo "Installing development tools (Git, Task, Go, Delve, rsync) via SSH at $VM_IP..."
        
        ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{.VM_USER}}@$VM_IP "
          set -e
          echo 'Installing git, curl, rsync, and build tools...'
          sudo apt-get update -qq
          sudo apt-get install -y git curl rsync build-essential binutils binutils-aarch64-linux-gnu binutils-gold gcc libc6-dev
        
          # Install Task
          if ! command -v task >/dev/null 2>&1; then
            echo 'Installing Task...'
            curl -1sLf 'https://dl.cloudsmith.io/public/task/task/setup.deb.sh' | sudo -E bash
            sudo apt-get update -qq
            sudo apt-get install -y task
          else
            echo 'Task already installed, skipping...'
          fi
        
          cd /mnt/solo-weaver
          task install:go
        
          echo 'âœ“ Development tools installed successfully!'
        "
  
  vm:ensure-exists:
    desc: "Ensure the working VM exists, creating it if necessary"
    internal: true
    cmds:
      - echo "VM '{{.VM_NAME}}' not found, creating it from golden image..."
      - task: vm:reset
    status:
      - utmctl status "{{.VM_NAME}}" >/dev/null 2>&1
  
  vm:stop:
    desc: "Stop the working VM instance"
    cmds:
      - |
        echo "Stopping VM '{{.VM_NAME}}'..."
        
        if utmctl status "{{.VM_NAME}}" >/dev/null 2>&1; then
          utmctl stop "{{.VM_NAME}}"
          echo "âœ“ VM stopped successfully!"
        else
          echo "VM '{{.VM_NAME}}' not found or already stopped."
        fi
  
  vm:ssh:
    desc: "SSH into the running VM"
    silent: true
    interactive: true
    deps:
      - "vm:start"
    cmds:
      - |
        VM_IP=$({{.GET_VM_IP}} get_vm_ip)
        
        echo "Connecting to VM at $VM_IP..."
        env -i HOME="$HOME" USER="$USER" TERM="${TERM:-xterm}" \
        ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -t {{.VM_USER}}@$VM_IP "cd /mnt/solo-weaver 2>/dev/null || true; exec \$SHELL -l"
  
  vm:test:unit:
    desc: "Run all unit tests in a UTM VM (useful for testing system-level functionality)"
    deps:
      - "vm:start"
    cmds:
      - cmd: |
          VM_IP=$({{.GET_VM_IP}} get_vm_ip)
          
          echo "Running unit tests with verbose output in UTM VM at $VM_IP..."
          
          # Check if VM is accessible
          if ! ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{.VM_USER}}@$VM_IP "echo 'VM is accessible'" 2>/dev/null; then
            echo "Error: Cannot connect to VM at $VM_IP. Please ensure the VM is running with 'task vm:start'."
            exit 1
          fi
          
          # Install dependencies and run tests on the VM with verbose output
          ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{.VM_USER}}@$VM_IP "
            source /etc/profile.d/go.sh 2>/dev/null || true
            cd /mnt/solo-weaver && sudo -E PATH=\"\$PATH\" task test:unit:verbose
          "
  
  vm:test:integration:
    desc: "Run all integration tests in a UTM VM with cache proxies (useful for testing system-level functionality). Use TEST_NAME to run a specific test, e.g., task vm:test:integration TEST_NAME='^Test_InitializeCluster_Fresh_Integration$'"
    deps:
      - vm:start
    cmds:
      - cmd: |
          VM_IP=$({{.GET_VM_IP}} get_vm_ip)
          
          echo "Running integration tests with verbose output in UTM VM at $VM_IP..."
          
          # Install dependencies and run tests on the VM with verbose output
          ssh -i {{.SSH_PRIVATE_KEY}} \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ExitOnForwardFailure=yes \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=3 \
              -R 3128:localhost:3128 \
              -R 8081:localhost:8081 \
              -R 5050:localhost:5050 \
              {{.VM_USER}}@$VM_IP "
            source /etc/profile.d/go.sh 2>/dev/null || true
            cd /mnt/solo-weaver &&
            echo 'Using cache infrastructure via SSH tunnels:' &&
            echo '  - HTTP/HTTPS proxy at localhost:3128 (Squid with SSL MITM - binaries, packages)' &&
            echo '  - Go module proxy at localhost:8081 (Go dependencies)' &&
            echo '  - Registry mirror at localhost:5050 (container images)' &&
            echo '' &&
            echo 'Verifying SSH tunnels are active...' &&
            netstat -tln | grep -E ':(3128|8081|5050)' || echo 'WARNING: Some tunnels may not be active yet' &&
            echo '' &&
            echo 'Testing proxy connectivity...' &&
            timeout 5 nc -zv localhost 3128 2>&1 && echo 'âœ“ Squid proxy (3128) is reachable' || echo 'âœ— Squid proxy (3128) is NOT reachable' &&
            timeout 5 nc -zv localhost 8081 2>&1 && echo 'âœ“ Go proxy (8081) is reachable' || echo 'âœ— Go proxy (8081) is NOT reachable' &&
            timeout 5 nc -zv localhost 5050 2>&1 && echo 'âœ“ Registry mirror (5050) is reachable' || echo 'âœ— Registry mirror (5050) is NOT reachable' &&
            echo '' &&
            export HTTP_PROXY=http://localhost:3128
            export HTTPS_PROXY=http://localhost:3128
            export NO_PROXY=localhost,127.0.0.1,::1,.local,.svc,.cluster.local,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16
            export SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
            export CURL_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt
            export REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt
            export GODEBUG=http2debug=0
            export GOPROXY=http://localhost:8081,https://proxy.golang.org,direct
            export GOSUMDB=sum.golang.org
            echo 'Environment variables set:' &&
            echo '  HTTP_PROXY='\$HTTP_PROXY &&
            echo '  HTTPS_PROXY='\$HTTPS_PROXY &&
            echo '  NO_PROXY='\$NO_PROXY &&
            echo '  SSL_CERT_FILE='\$SSL_CERT_FILE &&
            echo '  GOPROXY='\$GOPROXY &&
            echo '' &&
            sudo --preserve-env=HTTP_PROXY,HTTPS_PROXY,NO_PROXY,SSL_CERT_FILE,CURL_CA_BUNDLE,REQUESTS_CA_BUNDLE,GOPROXY,GOSUMDB,GODEBUG,GOPATH,PATH \
              task test:integration:verbose TEST_NAME={{.TEST_NAME}}
          "
  
  vm:status:
    desc: "Show status of all VMs"
    cmds:
      - |
        echo "VM Status:"
        echo "=========="
        echo "Current VM_OS_TYPE: {{.VM_OS_TYPE}}"
        echo "Current VM_NAME: {{.VM_NAME}}"
        echo ""
        echo "All UTM VMs:"
        utmctl list 2>/dev/null || echo "UTM not available or no VMs found"
  
  vm:clean:
    desc: "Stop and delete the working VM instance"
    cmds:
      - task: vm:stop
      - |
        echo "Deleting working VM '{{.VM_NAME}}'..."
        
        if utmctl status "{{.VM_NAME}}" >/dev/null 2>&1; then
          utmctl delete "{{.VM_NAME}}"
          echo "âœ“ Working VM deleted successfully!"
        else
          echo "Working VM not found or already deleted."
        fi
  
  vm:recreate:golden:
    desc: "Re-download the golden VM image"
    cmds:
      - task: vm:delete:golden
      - task: vm:setup
  
  vm:delete:golden:
    desc: "Delete the golden VM"
    cmds:
      - |
        echo "Deleting golden VM..."
        
        if utmctl status "{{.VM_GOLDEN_NAME}}" >/dev/null 2>&1; then
          echo "Found golden VM, deleting..."
          utmctl stop "{{.VM_GOLDEN_NAME}}" 2>/dev/null || true
          sleep 2
          utmctl delete "{{.VM_GOLDEN_NAME}}"
          echo "âœ“ Golden VM deleted successfully!"
        else
          echo "Golden VM not found or already deleted."
        fi
  
  # =============================================================================
  # Cache Proxy Tasks - Optimize integration test performance
  # =============================================================================
  
  proxy:start:
    desc: "Start cache proxy infrastructure (HTTP/HTTPS proxy, container registry mirror, Go proxy)"
    dir: test/cache-proxy
    cmds:
      - |
        echo "Starting cache proxy infrastructure..."
        
        # Check if required ports are already bound
        bound_count=0
        REQUIRED_PORTS=(3128 8081 5050)
        
        # Gather listening ports with available tool (ss -> netstat -> lsof)
        LISTENING_PORTS=$(lsof -nP -iTCP -sTCP:LISTEN 2>/dev/null | awk 'NR>1 {print $9}' | sed -E 's/.*[:.]([0-9]+)$/\1/' | grep -E '^[0-9]+$' || true)
        
        # Count how many required ports are present in LISTENING_PORTS
        for p in "${REQUIRED_PORTS[@]}"; do
          if printf '%s\n' "$LISTENING_PORTS" | grep -x -q "$p"; then
            echo "Port $p is already bound"
            bound_count=$((bound_count+1))
          fi
        done
        
        if [ "$bound_count" -eq "${#REQUIRED_PORTS[@]}" ]; then
          echo "All required ports (${REQUIRED_PORTS[*]}) are bound â€” skipping cache proxy start"
          exit 0
        fi
        
        if [ "$bound_count" -ne "0" ]; then
          echo "Some required ports are bound â€” ensure proxy is active, skipping cache proxy start"
          exit 0
        fi
        
        if docker compose ps | grep -q "solo-weaver-cache-proxy.*Up"; then
          echo "Cache proxy is already running"
        else
          docker compose up -d
          echo "Waiting for services to be ready..."
          sleep 5
          echo ""
          echo "âœ“ Cache infrastructure started successfully!"
          echo ""
          echo "Services running:"
          echo "  â€¢ HTTP/HTTPS Proxy:    http://localhost:3128 (Squid with SSL MITM)"
          echo "  â€¢ Container Registry:  http://localhost:5050 (mirrors registry.k8s.io)"
          echo "  â€¢ Go Module Proxy:     http://localhost:8081"
          echo ""
          echo "To use the proxies, set these environment variables:"
          echo "  export HTTP_PROXY=http://localhost:3128"
          echo "  export HTTPS_PROXY=http://localhost:3128"
          echo "  export GOPROXY=http://localhost:8081"
          echo ""
          echo "âš ï¸  For HTTPS caching, install the CA certificate on your VMs:"
          echo "  task proxy:install-ca-cert"
          echo ""
          echo "For CRI-O registry mirror, the registries.conf is installed during test setup."
        fi
  
  proxy:install-ca-cert:
    desc: "Install MITM proxy CA certificate in VM for HTTPS caching"
    deps:
      - proxy:start
      - vm:start
    cmds:
      - cmd: |
          VM_IP=$({{.GET_VM_IP}} get_vm_ip)
          CA_CERT_PATH="test/cache-proxy/ca-cert.pem"
          
          echo "Installing Squid MITM proxy CA certificate in VM..."
          
          # Extract CA certificate from Squid container if not already cached
          if [[ ! -f "$CA_CERT_PATH" ]]; then
            echo "CA certificate not found at $CA_CERT_PATH"
            echo "Extracting CA certificate from Squid proxy container..."
            docker cp solo-weaver-cache-proxy:/etc/squid/certs/ca-cert.pem "$CA_CERT_PATH"
            echo "âœ“ CA certificate extracted to $CA_CERT_PATH"
          fi
          
          # Show certificate details
          echo "Certificate details:"
          openssl x509 -in "$CA_CERT_PATH" -noout -subject -dates | head -3
          
          # Copy to VM
          echo "Copying CA certificate to VM..."
          scp -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "$CA_CERT_PATH" {{.VM_USER}}@$VM_IP:/tmp/solo-weaver-ca.crt
          
          # Install in VM
          echo "Installing certificate in VM..."
          ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{.VM_USER}}@$VM_IP \
            "sudo cp /tmp/solo-weaver-ca.crt /usr/local/share/ca-certificates/solo-weaver-ca.crt && \
             sudo chmod 644 /usr/local/share/ca-certificates/solo-weaver-ca.crt && \
             sudo update-ca-certificates --fresh && \
             echo 'Verifying CA certificate was added to bundle...' && \
             if grep -q 'Solo Weaver Cache Proxy CA' /etc/ssl/certs/ca-certificates.crt; then \
               echo 'âœ“ CA certificate verified in bundle'; \
             else \
               echo 'âš  Warning: CA certificate not found in bundle'; \
             fi"
          
          echo ""
          echo "âœ… Squid MITM CA certificate installed successfully!"
          echo ""
          echo "The VM can now use the Squid proxy for HTTPS caching with SSL interception."
          echo "Run: task vm:test:integration"
  
  proxy:rebuild:
    desc: "Rebuild and restart the cache proxy (after code changes)"
    dir: test/cache-proxy
    cmds:
      - |
        echo "Rebuilding cache proxy (forcing fresh build)..."
        
        # Remove cached CA certificate since we're regenerating it
        rm -f ca-cert.pem ca-key.pem || true
        echo "âœ“ Removed cached CA certificates"
        
        docker compose down -v || true
        docker rmi -f $(docker images -q cache-proxy-cache-proxy 2>/dev/null) 2>/dev/null || true
        docker compose build --no-cache
        docker compose up -d
        sleep 2
        echo ""
        echo "âœ… Proxy rebuilt and restarted with new CA certificate"
        echo ""
        echo "Checking status..."
        docker compose ps
        echo ""
        echo "Recent logs:"
        docker compose logs --tail=5
        echo ""
        echo "âš ï¸  IMPORTANT: New CA certificate generated!"
        echo "   Run 'task proxy:install-ca-cert' to install in VM"
        echo "   Or run 'task vm:test:integration' which will install it automatically"
  
  proxy:stop:
    desc: "Stop the cache proxy server"
    dir: test/cache-proxy
    cmds:
      - docker compose down
  
  proxy:status:
    desc: "Show cache proxy status and statistics"
    dir: test/cache-proxy
    cmds:
      - |
        echo "Cache Proxy Status:"
        echo "==================="
        docker compose ps
        echo ""
        if docker ps | grep -q solo-weaver-cache-proxy; then
          echo "Cache sizes:"
          docker exec solo-weaver-cache-proxy du -sh /var/cache/squid 2>/dev/null | awk '{print "  HTTP/HTTPS cache (Squid): " $1}'
          docker exec solo-weaver-registry-mirror du -sh /var/lib/registry 2>/dev/null | awk '{print "  Registry: " $1}' || true
          docker exec solo-weaver-goproxy du -sh /go 2>/dev/null | awk '{print "  Go modules: " $1}' || true
        
          echo ""
          echo "Large-object cache stats (>1MB):"
          if docker exec solo-weaver-cache-proxy test -f /var/log/squid/access.log 2>/dev/null; then
            LOGCMD="docker exec solo-weaver-cache-proxy sh -c"
        
            # field 5 = bytes sent to client
            TOTAL=$($LOGCMD "awk '\$5 >= 1000000 && \$4 ~ /TCP_/ {c++} END {print c+0}' /var/log/squid/access.log" || echo 0)
            HITS=$($LOGCMD "awk '\$5 >= 1000000 && \$4 ~ /(TCP_HIT|TCP_MEM_HIT|TCP_REFRESH_HIT|TCP_REFRESH_UNMODIFIED|TCP_IMS_HIT)/ {c++} END {print c+0}' /var/log/squid/access.log" || echo 0)
            MISSES=$($LOGCMD "awk '\$5 >= 1000000 && \$4 ~ /(TCP_MISS|TCP_CLIENT_REFRESH_MISS|TCP_SWAPFAIL_MISS)/ {c++} END {print c+0}' /var/log/squid/access.log" || echo 0)
        
            echo "  Total large responses: $TOTAL"
            echo "  Large hits:   $HITS"
            echo "  Large misses: $MISSES"
        
            if [ "$TOTAL" -gt 0 ]; then
              HIT_RATE=$(echo "scale=2; ($HITS * 100) / $TOTAL" | bc)
              echo "  Large-object hit rate: ${HIT_RATE}%"
            fi
          else
            echo "  No access log yet"
          fi
        
          echo ""
          echo "Recent activity (last 10 requests):"
          docker exec solo-weaver-cache-proxy tail -10 /var/log/squid/access.log 2>/dev/null | awk '{print "  " $4 " " $7}' || echo "  No activity yet"
        
        else
          echo "Cache proxy is not running"
          echo "Start it with: task proxy:start"
        fi

  # ===========================
  # Observability (Core Tasks)
  # ===========================
  # Note: These tasks are used by:
  #   - vm:observability:start (VM-based development)
  #   - CI/CD workflows (GitHub Actions, GitLab CI, etc.)
  #   - Local Kind/k3d Kubernetes clusters

  vault:start:
    desc: "Start Vault and initialize with development secrets"
    dir: test/observability
    cmds:
      - |
        echo "ğŸš€ Starting Vault..."
        docker compose up -d vault
      - |
        echo "â³ Initializing Vault with secrets..."
        ./init-vault.sh
      - |
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âœ… Vault started and configured!"
        echo ""
        echo "ğŸ” Vault UI:  http://localhost:8200"
        echo "ğŸ”‘ Token:     devtoken"
        echo "ğŸ‘¤ ESO User:  eso-user / eso-password"
        echo ""
        echo "ğŸ“¦ Secrets created for cluster: vm-cluster"
        echo "   â€¢ secret/grafana/alloy/vm-cluster/prometheus"
        echo "   â€¢ secret/grafana/alloy/vm-cluster/loki"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  vault:stop:
    desc: "Stop Vault container"
    dir: test/observability
    cmds:
      - docker compose stop vault

  vault:clean:
    desc: "Stop Vault and remove all data"
    dir: test/observability
    cmds:
      - docker compose down vault
      - docker volume rm solo-weaver-vault-data 2>/dev/null || true

  vault:setup-secret-store:
    desc: "Configure ClusterSecretStore to connect ESO to Vault (auto-detects node IP)"
    dir: test/observability
    cmds:
      - |
        echo "ğŸ”§ Configuring ClusterSecretStore for kubeadm cluster..."
        
        # Check if External Secrets Operator is installed
        echo "ğŸ“‹ Checking for External Secrets Operator..."
        if ! kubectl get crd clustersecretstores.external-secrets.io &>/dev/null; then
          echo "âŒ Error: External Secrets Operator CRDs not found!"
          echo ""
          echo "External Secrets Operator must be installed first."
          echo ""
          echo "To install ESO, run:"
          echo "  weaver block node install --profile=local --config=/mnt/solo-weaver/test/config/config.yaml"
          echo ""
          echo "Or check if ESO pods are running:"
          echo "  kubectl get pods -n external-secrets"
          exit 1
        fi
        echo "âœ“ External Secrets Operator CRDs found"
        
        # Check if ESO pods are running
        if ! kubectl get pods -n external-secrets &>/dev/null; then
          echo "âš ï¸  Warning: external-secrets namespace not found"
          echo "ESO may not be fully installed yet"
        else
          POD_COUNT=$(kubectl get pods -n external-secrets --no-headers 2>/dev/null | wc -l)
          echo "âœ“ Found $POD_COUNT ESO pod(s) in external-secrets namespace"
        fi
        
        # Get the node's internal IP (works for kubeadm)
        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
        
        if [ -z "$NODE_IP" ]; then
          echo "âŒ Error: Could not determine node IP from Kubernetes"
          echo "Trying alternative method..."
          NODE_IP=$(ip route get 1 | awk '{print $7; exit}')
        fi
        
        if [ -z "$NODE_IP" ]; then
          echo "âŒ Error: Could not determine node IP"
          exit 1
        fi
        
        echo "âœ“ Detected node IP: $NODE_IP"
        echo "âœ“ Vault URL will be: http://$NODE_IP:8200"
        
        # Create temporary file with IP replaced
        TEMP_FILE=$(mktemp)
        sed "s|REPLACE_WITH_NODE_IP|http://$NODE_IP:8200|g" cluster-secret-store-local.yaml > "$TEMP_FILE"
        
        # Apply the configured manifest
        echo "ğŸ“ Applying ClusterSecretStore..."
        kubectl apply -f "$TEMP_FILE"
        
        # Cleanup
        rm -f "$TEMP_FILE"
        
        echo ""
        echo "â³ Waiting for ClusterSecretStore to be ready..."
        sleep 3
        
        # Check status
        STATUS=$(kubectl get clustersecretstore vault-secret-store -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "Unknown")
        
        if [ "$STATUS" = "True" ]; then
          echo "âœ… ClusterSecretStore is ready!"
        else
          echo "âš ï¸  ClusterSecretStore status: $STATUS"
          echo ""
          echo "Checking details:"
          kubectl describe clustersecretstore vault-secret-store | tail -20
        fi
        
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âœ… ClusterSecretStore configured!"
        echo ""
        echo "ğŸ“‹ Configuration:"
        echo "   Vault URL: http://$NODE_IP:8200"
        echo "   ESO User:  eso-user"
        echo ""
        echo "ğŸ“ Next step: Install observability"
        echo "   weaver block node install --profile=local --config=/mnt/solo-weaver/test/config/config_with_observability.yaml"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  observability:start:
    desc: "Start observability stack (used by VM, CI/CD, and Kind/k3d)"
    dir: test/observability
    deps: [vault:start]
    cmds:
      - docker compose up -d prometheus loki grafana
      - |
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âœ… Observability stack started!"
        echo ""
        echo "ğŸ“¦ This task is used by:"
        echo "   â€¢ VM development (via task vm:observability:start)"
        echo "   â€¢ CI/CD workflows (GitHub Actions, GitLab CI)"
        echo "   â€¢ Local Kind/k3d clusters"
        echo ""
        echo "ğŸŒ Services:"
        echo "   â€¢ Vault:      http://localhost:8200 (token: devtoken)"
        echo "   â€¢ Prometheus: http://localhost:9090"
        echo "   â€¢ Loki:       http://localhost:3100"
        echo "   â€¢ Grafana:    http://localhost:3000"
        echo ""
        echo "ğŸ” Vault has been initialized with development secrets"
        echo ""
        echo "ğŸ“ Next step: Apply ClusterSecretStore to connect ESO to Vault"
        echo "   kubectl apply -f test/observability/cluster-secret-store-local.yaml"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  observability:stop:
    desc: "Stop observability stack"
    dir: test/observability
    cmds:
      - docker compose down

  observability:clean:
    desc: "Stop and remove all observability data (volumes)"
    dir: test/observability
    cmds:
      - docker compose down -v
      - echo "âœ… Observability stack stopped and data removed"

  observability:logs:
    desc: "Show logs from observability stack"
    dir: test/observability
    cmds:
      - docker compose logs -f

  observability:status:
    desc: "Show observability stack status"
    dir: test/observability
    cmds:
      - |
        echo "Observability Stack Status:"
        echo "==========================="
        docker compose ps
        echo ""
        if docker ps | grep -q solo-weaver-prometheus; then
          echo "Service URLs:"
          echo "  â€¢ Prometheus: http://localhost:9090"
          echo "  â€¢ Loki:       http://localhost:3100"
          echo "  â€¢ Grafana:    http://localhost:3000"
        else
          echo "Observability stack is not running"
          echo "Start it with: task observability:start"
          echo ""
          echo "ğŸ’¡ For VM-based development, use: task vm:observability:start"
        fi

  # ===========================
  # VM Docker & Observability Setup
  # ===========================

  vm:install-docker:
    desc: "Install Docker in the VM (Debian/Ubuntu)"
    deps: [vm:start]
    cmds:
      - |
        echo "ğŸ”§ Installing Docker in VM..."
        {{.GET_VM_IP}}
        VM_IP=$(get_vm_ip)
        
        if [ -z "$VM_IP" ]; then
          echo "âŒ Could not determine VM IP. Is the VM running?"
          exit 1
        fi
        
        ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no {{.VM_USER}}@$VM_IP 'bash -s' <<'ENDSSH'
        set -euo pipefail
        
        echo "ğŸ“¦ Checking if Docker is already installed..."
        if command -v docker &> /dev/null; then
          echo "âœ… Docker is already installed"
          docker --version
          exit 0
        fi
        
        echo "ğŸ“¥ Installing Docker..."
        
        # Update package index
        sudo apt-get update
        
        # Install prerequisites
        sudo apt-get install -y \
          ca-certificates \
          curl \
          gnupg \
          lsb-release
        
        # Add Docker's official GPG key
        sudo mkdir -p /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/$(lsb_release -is | tr '[:upper:]' '[:lower:]')/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
        
        # Set up the repository
        echo \
          "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/$(lsb_release -is | tr '[:upper:]' '[:lower:]') \
          $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
        
        # Install Docker Engine
        sudo apt-get update
        sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        
        # Add current user to docker group
        sudo usermod -aG docker $USER
        
        # Start and enable Docker
        sudo systemctl start docker
        sudo systemctl enable docker
        
        echo "âœ… Docker installed successfully!"
        docker --version
        docker compose version
        
        echo ""
        echo "âš ï¸  Note: You may need to log out and back in for group changes to take effect"
        echo "   Or run: newgrp docker"
        ENDSSH

  vm:observability:start:
    desc: "Set up observability stack in the VM"
    deps: [vm:install-docker]
    cmds:
      - |
        echo "ğŸš€ Setting up observability stack in VM..."
        {{.GET_VM_IP}}
        VM_IP=$(get_vm_ip)
        
        if [ -z "$VM_IP" ]; then
          echo "âŒ Could not determine VM IP. Is the VM running?"
          exit 1
        fi
        
        echo "ğŸ”§ Starting observability stack in VM..."
        # Task is already installed in the VM and /mnt/solo-weaver is already synced
        # So we can just use 'task observability:start' directly!
        # Use sudo newgrp to ensure docker group permissions are active
        ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no {{.VM_USER}}@$VM_IP \
          "cd /mnt/solo-weaver && sudo -u {{.VM_USER}} newgrp docker -c 'task observability:start'"
        
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âœ… Observability stack setup complete!"
        echo ""
        echo "ğŸ” Vault has been initialized with development secrets"
        echo ""
        echo "ğŸ“‹ Next steps:"
        echo "   1. SSH into VM: task vm:ssh"
        echo "   2. Apply ClusterSecretStore: task vault:setup-secret-store"
        echo "   3. Deploy with Alloy: sudo weaver kube cluster install --alloy-enabled ..."
        echo ""
        echo "ğŸ’¡ To access from your Mac, use SSH port forwarding:"
        echo "   task vm:observability-forward"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  vm:observability:stop:
    desc: "Stop observability stack in the VM"
    cmds:
      - |
        echo "ğŸ›‘ Stopping observability stack in VM..."
        {{.GET_VM_IP}}
        VM_IP=$(get_vm_ip)
        
        if [ -z "$VM_IP" ]; then
          echo "âŒ Could not determine VM IP. Is the VM running?"
          exit 1
        fi
        
        ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no {{.VM_USER}}@$VM_IP \
          "cd /mnt/solo-weaver && sudo -u {{.VM_USER}} newgrp docker -c 'task observability:stop'"
        echo "âœ… Observability stack stopped"

  vm:observability:clean:
    desc: "Stop and remove all observability data in the VM"
    cmds:
      - |
        echo "ğŸ§¹ Cleaning observability stack in VM..."
        {{.GET_VM_IP}}
        VM_IP=$(get_vm_ip)
        
        if [ -z "$VM_IP" ]; then
          echo "âŒ Could not determine VM IP. Is the VM running?"
          exit 1
        fi
        
        ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no {{.VM_USER}}@$VM_IP \
          "cd /mnt/solo-weaver && sudo -u {{.VM_USER}} newgrp docker -c 'task observability:clean'"
        echo "âœ… Observability stack cleaned"

  vm:observability-forward:
    desc: "Forward observability ports from VM to Mac (Vault:8200, Prometheus:9090, Loki:3100, Grafana:3000)"
    cmds:
      - |
        echo "ğŸ”Œ Setting up port forwarding for observability stack..."
        {{.GET_VM_IP}}
        VM_IP=$(get_vm_ip)
        
        if [ -z "$VM_IP" ]; then
          echo "âŒ Could not determine VM IP. Is the VM running?"
          exit 1
        fi
        
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸŒ Forwarding ports from VM to your Mac:"
        echo "   â€¢ Vault:      localhost:8200 â†’ VM:8200"
        echo "   â€¢ Prometheus: localhost:9090 â†’ VM:9090"
        echo "   â€¢ Loki:       localhost:3100 â†’ VM:3100"
        echo "   â€¢ Grafana:    localhost:3000 â†’ VM:3000"
        echo ""
        echo "ğŸ“Š Access in your browser:"
        echo "   â€¢ http://localhost:8200 (Vault UI, token: devtoken)"
        echo "   â€¢ http://localhost:9090 (Prometheus)"
        echo "   â€¢ http://localhost:3000 (Grafana)"
        echo ""
        echo "âš ï¸  Press Ctrl+C to stop port forwarding"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        
        ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no \
          -L 8200:localhost:8200 \
          -L 9090:localhost:9090 \
          -L 3100:localhost:3100 \
          -L 3000:localhost:3000 \
          {{.VM_USER}}@$VM_IP \
          'echo "âœ… Port forwarding active. Press Ctrl+C to stop..." && tail -f /dev/null'

  # ===========================
  # Teleport Local Development
  # ===========================

  teleport:start:
    desc: "Start Teleport server and generate values file for local development"
    dir: test/teleport
    cmds:
      - |
        echo "ğŸ”§ Setting up Teleport server..."
        
        # Step 1: Get node IP first (we need it for the server config)
        NODE_IP=""
        if command -v kubectl &> /dev/null && kubectl get nodes &> /dev/null; then
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}' 2>/dev/null)
        fi
        if [ -z "$NODE_IP" ]; then
          NODE_IP=$(ip route get 1 2>/dev/null | awk '{print $7; exit}')
        fi
        if [ -z "$NODE_IP" ]; then
          NODE_IP=$(hostname -I 2>/dev/null | awk '{print $1}')
        fi
        if [ -z "$NODE_IP" ]; then
          echo "âŒ Could not determine node IP address"
          exit 1
        fi
        echo "âœ“ Detected node IP: $NODE_IP"
        
        # Step 2: Create volumes
        docker volume create teleport_teleport-config 2>/dev/null || true
        docker volume create teleport_teleport-data 2>/dev/null || true
        
        # Step 3: Remove existing config file if present
        docker run --rm -v teleport_teleport-config:/etc/teleport alpine rm -f /etc/teleport/teleport.yaml 2>/dev/null || true
        
        # Step 4: Generate config file with the node IP as public_addr
        # This is critical - the agent needs to know the real address to connect back to
        echo "ğŸ“ Generating Teleport configuration with public_addr=$NODE_IP:3080..."
        docker run --hostname "$NODE_IP" --rm \
          --entrypoint=/usr/local/bin/teleport \
          -v teleport_teleport-config:/etc/teleport \
          public.ecr.aws/gravitational/teleport-distroless:18.6.4 \
          configure --roles=proxy,auth --public-addr="$NODE_IP:3080" -o /etc/teleport/teleport.yaml
        
        # Step 5: Start Teleport
        echo "ğŸš€ Starting Teleport server..."
        docker compose up -d
        
        # Step 6: Wait for it to be ready
        echo "â³ Waiting for Teleport to be ready..."
        max_attempts=30
        attempt=0
        while ! curl --insecure -s https://localhost:3080/webapi/ping > /dev/null 2>&1; do
          attempt=$((attempt + 1))
          if [ $attempt -ge $max_attempts ]; then
            echo "âš ï¸  Teleport may still be starting. Check logs with: docker logs solo-weaver-teleport"
            exit 1
          fi
          echo "   Waiting... (attempt $attempt/$max_attempts)"
          sleep 2
        done
        
        echo "âœ… Teleport server is running!"
        
        # Step 7: Add certificate to system trust store
        echo ""
        echo "ğŸ” Adding Teleport certificate to system trust store..."
        CERT_FILE="/tmp/teleport-server.crt"
        echo | openssl s_client -connect localhost:3080 -showcerts 2>/dev/null | \
          openssl x509 -outform PEM > "$CERT_FILE"
        if [ -s "$CERT_FILE" ]; then
          sudo cp "$CERT_FILE" /usr/local/share/ca-certificates/teleport-server.crt
          sudo update-ca-certificates
          echo "âœ… Certificate added to system trust store"
        else
          echo "âš ï¸  Could not extract certificate (will need manual trust setup)"
        fi
        
        # Step 8: Generate a join token
        echo ""
        echo "ğŸ« Generating Teleport join token..."
        TOKEN=$(docker exec solo-weaver-teleport tctl tokens add --type=kube --ttl=24h --format=text 2>/dev/null)
        
        if [ -z "$TOKEN" ]; then
          echo "âš ï¸  Could not generate token automatically. Use 'task teleport:new-token' later."
          TOKEN="REPLACE_WITH_JOIN_TOKEN"
        fi
        
        # Step 9: Create the configured values file
        OUTPUT_FILE="/tmp/teleport-values-configured.yaml"
        sed "s|REPLACE_WITH_NODE_IP|$NODE_IP|g; s|REPLACE_WITH_JOIN_TOKEN|$TOKEN|g" teleport-values-local.yaml > "$OUTPUT_FILE"
        
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âœ… Teleport is ready for local development!"
        echo ""
        echo "ğŸŒ Web UI: https://localhost:3080"
        echo "          https://$NODE_IP:3080 (from k8s pods)"
        echo ""
        echo "ğŸ“‹ Configuration:"
        echo "   Proxy Addr: $NODE_IP:3080"
        echo "   Values file: $OUTPUT_FILE"
        echo ""
        echo "ğŸ“ Next step: Install cluster with Teleport agent"
        echo "   sudo weaver block node install \\"
        echo "     --profile=local \\"
        echo "     --teleport-enabled \\"
        echo "     --teleport-values=$OUTPUT_FILE"
        echo ""
        echo "ğŸ‘¤ To create an admin user:"
        echo "   docker exec solo-weaver-teleport tctl users add admin --roles=editor,access --logins=root"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  teleport:stop:
    desc: "Stop Teleport server"
    dir: test/teleport
    cmds:
      - docker compose down

  teleport:clean:
    desc: "Stop and remove all Teleport data (volumes)"
    dir: test/teleport
    cmds:
      - docker compose down -v
      - docker volume rm teleport_teleport-config teleport_teleport-data 2>/dev/null || true
      - echo "âœ… Teleport server stopped and data removed"

  teleport:logs:
    desc: "Show logs from Teleport server"
    dir: test/teleport
    cmds:
      - docker compose logs -f

  teleport:kube-token:
    desc: "Generate a new Kubernetes agent join token"
    dir: test/teleport
    cmds:
      - |
        echo "ğŸ« Generating new Teleport Kubernetes agent join token..."
        TOKEN=$(docker exec solo-weaver-teleport tctl tokens add --type=kube --ttl=24h --format=text 2>/dev/null)
        if [ -z "$TOKEN" ]; then
          echo "âŒ Failed to generate token. Is Teleport running?"
          exit 1
        fi
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âœ… New Kubernetes agent join token generated!"
        echo ""
        echo "Token: $TOKEN"
        echo ""
        echo "ğŸ“ Run 'task teleport:start' to regenerate the values file with this token"
        echo "   Or manually update: /tmp/teleport-values-configured.yaml"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  teleport:status:
    desc: "Show Teleport server status"
    dir: test/teleport
    cmds:
      - |
        echo "Teleport Server Status:"
        echo "======================="
        docker compose ps
        echo ""
        if docker ps | grep -q solo-weaver-teleport; then
          echo "Service URLs:"
          echo "  â€¢ Web UI: https://localhost:3080"
          echo ""
          echo "Cluster info:"
          docker exec solo-weaver-teleport tctl status 2>/dev/null || echo "  (waiting for Teleport to be ready...)"
        else
          echo "Teleport server is not running"
          echo "Start it with: task teleport:start"
        fi

  teleport:node-agent-token:
    desc: "Generate a fresh node agent token for local dev"
    dir: test/teleport
    cmds:
      - |
        echo "ğŸ”§ Generating Teleport node agent token..."
        
        # Check if Teleport server is running
        if ! docker ps | grep -q solo-weaver-teleport; then
          echo "âŒ Teleport server is not running. Start it first with: task teleport:start"
          exit 1
        fi
        
        # Generate a fresh token with short TTL (15 minutes)
        echo "ğŸ« Generating fresh node agent token (15 minute TTL)..."
        NEW_TOKEN=$(docker exec solo-weaver-teleport tctl tokens add --type=node --ttl=15m --format=text 2>/dev/null)
        
        if [ -z "$NEW_TOKEN" ]; then
          echo "âŒ Failed to generate token. Is Teleport ready?"
          exit 1
        fi
        
        # Get node IP for the proxy address
        NODE_IP=""
        if command -v kubectl &> /dev/null && kubectl get nodes &> /dev/null; then
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}' 2>/dev/null)
        fi
        if [ -z "$NODE_IP" ]; then
          NODE_IP=$(ip route get 1 2>/dev/null | awk '{print $7; exit}')
        fi
        if [ -z "$NODE_IP" ]; then
          NODE_IP=$(hostname -I 2>/dev/null | awk '{print $1}')
        fi
        
        if [ -z "$NODE_IP" ]; then
          echo "âŒ Could not determine node IP"
          exit 1
        fi
        
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âœ… Node agent token generated!"
        echo ""
        echo "ğŸ“‹ Token:     $NEW_TOKEN"
        echo "ğŸŒ Proxy:     ${NODE_IP}:3080"
        echo "â±ï¸  Expires:   15 minutes"
        echo ""
        echo "ğŸ“ To install with weaver, run:"
        echo "   sudo weaver block node install \\"
        echo "     --profile=local \\"
        echo "     --teleport-enabled \\"
        echo "     --teleport-values=/tmp/teleport-values-configured.yaml \\"
        echo "     --teleport-node-agent-token=$NEW_TOKEN \\"
        echo "     --teleport-node-agent-proxy=${NODE_IP}:3080"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  # ===========================
  # VM Teleport Setup
  # ===========================

  vm:teleport:start:
    desc: "Start Teleport server in the VM"
    deps: [vm:install-docker]
    cmds:
      - |
        echo "ğŸš€ Starting Teleport server in VM..."
        {{.GET_VM_IP}}
        VM_IP=$(get_vm_ip)
        
        if [ -z "$VM_IP" ]; then
          echo "âŒ Could not determine VM IP. Is the VM running?"
          exit 1
        fi
        
        ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no {{.VM_USER}}@$VM_IP \
          "cd /mnt/solo-weaver && sudo -u {{.VM_USER}} newgrp docker -c 'task teleport:start'"
        
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âœ… Teleport server started in VM!"
        echo ""
        echo "ğŸ“‹ Next steps:"
        echo "   1. SSH into VM: task vm:ssh"
        echo "   2. Install with Teleport:"
        echo "      sudo weaver block node install \\"
        echo "        --profile=local \\"
        echo "        --teleport-enabled \\"
        echo "        --teleport-values=/mnt/solo-weaver/test/teleport/teleport-values-local.yaml"
        echo ""
        echo "ğŸ’¡ To access Teleport Web UI from your Mac:"
        echo "   task vm:teleport-forward"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  vm:teleport:stop:
    desc: "Stop Teleport server in the VM"
    cmds:
      - |
        echo "ğŸ›‘ Stopping Teleport server in VM..."
        {{.GET_VM_IP}}
        VM_IP=$(get_vm_ip)
        
        if [ -z "$VM_IP" ]; then
          echo "âŒ Could not determine VM IP. Is the VM running?"
          exit 1
        fi
        
        ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no {{.VM_USER}}@$VM_IP \
          "cd /mnt/solo-weaver && sudo -u {{.VM_USER}} newgrp docker -c 'task teleport:stop'"
        echo "âœ… Teleport server stopped"

  vm:teleport:clean:
    desc: "Stop and remove all Teleport data in the VM"
    cmds:
      - |
        echo "ğŸ§¹ Cleaning Teleport server in VM..."
        {{.GET_VM_IP}}
        VM_IP=$(get_vm_ip)
        
        if [ -z "$VM_IP" ]; then
          echo "âŒ Could not determine VM IP. Is the VM running?"
          exit 1
        fi
        
        ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no {{.VM_USER}}@$VM_IP \
          "cd /mnt/solo-weaver && sudo -u {{.VM_USER}} newgrp docker -c 'task teleport:clean'"
        echo "âœ… Teleport server cleaned"

  vm:teleport-forward:
    desc: "Forward Teleport ports from VM to Mac (Web UI:3080)"
    cmds:
      - |
        echo "ğŸ”Œ Setting up port forwarding for Teleport..."
        {{.GET_VM_IP}}
        VM_IP=$(get_vm_ip)
        
        if [ -z "$VM_IP" ]; then
          echo "âŒ Could not determine VM IP. Is the VM running?"
          exit 1
        fi
        
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸŒ Forwarding Teleport ports from VM to your Mac:"
        echo "   â€¢ Web UI:  localhost:3080 â†’ VM:3080"
        echo "   â€¢ SSH:     localhost:3023 â†’ VM:3023"
        echo "   â€¢ Tunnel:  localhost:3024 â†’ VM:3024"
        echo "   â€¢ Auth:    localhost:3025 â†’ VM:3025"
        echo "   â€¢ Kube:    localhost:3026 â†’ VM:3026"
        echo ""
        echo "ğŸ“Š Access in your browser:"
        echo "   â€¢ https://localhost:3080 (Teleport Web UI)"
        echo ""
        echo "âš ï¸  Press Ctrl+C to stop port forwarding"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        
        ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no \
          -L 3080:localhost:3080 \
          -L 3023:localhost:3023 \
          -L 3024:localhost:3024 \
          -L 3025:localhost:3025 \
          -L 3026:localhost:3026 \
          {{.VM_USER}}@$VM_IP \
          'echo "âœ… Port forwarding active. Press Ctrl+C to stop..." && tail -f /dev/null'
