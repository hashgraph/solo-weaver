version: 3
silent: false
output: prefixed
vars:
  OS: [ linux, darwin ]
  ARCH: [ amd64, arm64 ]
  GO_VERSION: 1.24.3
  LDFLAGS: "-w -s"
  # VM configuration
  VM_NAME: "solo-provisioner-debian"
  VM_GOLDEN_NAME: "solo-provisioner-debian-golden"
  # Set this to the actual URL or local path of your golden image (e.g., "https://storage.example.com/golden-image.utm" or "/path/to/golden-image.utm")
  VM_GOLDEN_IMAGE_URL: ""  # REQUIRED: Set to your golden image location before running tasks
  VM_USER: "provisioner"
  SSH_PRIVATE_KEY: "{{.PWD}}/.ssh/id_rsa_vm"
  SSH_PUBLIC_KEY: "{{.SSH_PRIVATE_KEY}}.pub"
  UTM_VMS_DIR: "{{.HOME}}/Library/Containers/com.utmapp.UTM/Data/Documents"
  GET_VM_IP: |
    get_vm_ip() {
      utmctl ip-address "{{.VM_NAME}}" 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1
    }

tasks:
  clean:
    cmds:
      - "rm -rf bin"
      - "rm -f unit-test-report.md"
      - "mkdir -p bin"
      - "go clean -cache -testcache"

  vendor:
    cmds:
      - "go mod vendor"

  lint:
    cmds:
      - "go fmt -x ./..."

  lint:check:
    cmds:
      - "R=$(go fmt ./...) && if [[ -n \"$R\" ]]; then echo \"The following files require formatting:\"; echo \"$R\"; exit 1; fi"

  build:
    deps:
      - "vendor"
    cmds:
      - task: "clean"
      - task: "generate"
      - task: "build:provisioner:all"
    sources:
      - "**/*.go"
    generates:
      - "bin/provisioner-linux-*"
      - "bin/provisioner-darwin-*"

  hash:
    deps:
      - "build"
    cmds:
      - task: "hash:provisioner:all"
    sources:
      - "bin/provisioner-linux-*"
      - "bin/provisioner-darwin-*"
    generates:
      - "bin/*.sha256"

  sign:
    deps:
      - "build"
    cmds:
      - task: "sign:provisioner:all"

  build:image:
    deps:
      - task: "hash"
    cmds:
      - "docker build -t solo-provisioner ."

  generate:
    cmds:
      - "go generate ./..."

  build:provisioner:all:
    desc: "Build the binary for all configured operating systems and architectures"
    cmds:
      - task: build:provisioner:all:os

  build:provisioner:all:os:
    internal: true
    desc: "Build the binary for all configured operating systems"
    cmds:
      - for:
          var: OS
        task: build:provisioner:all:arch
        vars:
          GOOS: "{{.ITEM}}"

  build:provisioner:all:arch:
    internal: true
    desc: "Build the binary for all configured architectures"
    cmds:
      - for:
          var: ARCH
        task: build:provisioner
        vars:
          GOOS: "{{.GOOS}}"
          GOARCH: "{{.ITEM}}"

  build:provisioner:
    internal: true
    desc: "Build the binary for the specified operating system and architecture"
    env:
      GOOS: "{{coalesce .GOOS OS}}"
      GOARCH: "{{coalesce .GOARCH ARCH}}"
    cmds:
      - cmd: go build -ldflags='{{.LDFLAGS}}' -trimpath -o bin/provisioner-{{coalesce .GOOS OS}}-{{coalesce .GOARCH ARCH}} ./cmd/provisioner
      - cmd: chmod +x bin/provisioner-{{coalesce .GOOS OS}}-{{coalesce .GOARCH ARCH}}

  hash:provisioner:all:
    desc: "Hash the binary binaries for all configured operating systems and architectures"
    cmds:
      - task: hash:provisioner:all:os

  hash:provisioner:all:os:
    internal: true
    desc: "Hash the binary binaries for all configured operating systems"
    cmds:
      - for:
          var: OS
        task: hash:provisioner:all:arch
        vars:
          GOOS: "{{.ITEM}}"

  hash:provisioner:all:arch:
    internal: true
    desc: "Hash the binary binaries for all configured architectures"
    cmds:
      - for:
          var: ARCH
        task: hash:provisioner
        vars:
          GOOS: "{{.GOOS}}"
          GOARCH: "{{.ITEM}}"

  hash:provisioner:
    internal: true
    desc: "Hash the binary binaries for the specified operating system and architecture"
    dir: bin
    cmds:
      - cmd: sha256sum provisioner-{{.GOOS}}-{{.GOARCH}} > provisioner-{{.GOOS}}-{{.GOARCH}}.sha256

  sign:provisioner:all:
    desc: "Sign the binary binaries for all configured operating systems and architectures"
    cmds:
      - task: sign:provisioner:all:os

  sign:provisioner:all:os:
    internal: true
    desc: "Sign the binary binaries for all configured operating systems"
    cmds:
      - for:
          var: OS
        task: sign:provisioner:all:arch
        vars:
          GOOS: "{{.ITEM}}"

  sign:provisioner:all:arch:
    internal: true
    desc: "Sign the binary binaries for all configured architectures"
    cmds:
      - for:
          var: ARCH
        task: sign:provisioner
        vars:
          GOOS: "{{.GOOS}}"
          GOARCH: "{{.ITEM}}"

  sign:provisioner:
    internal: true
    desc: "Sign the binary binaries for the specified operating system and architecture"
    env:
      GOOS: "{{coalesce .GOOS OS}}"
      GOARCH: "{{coalesce .GOARCH ARCH}}"
    cmds:
      - task: hash:provisioner
        vars:
          GOOS: "{{.GOOS}}"
          GOARCH: "{{.GOARCH}}"
      - cmd: gpg --batch --yes --armor --output bin/provisioner-{{.GOOS}}-{{.GOARCH}}.sha256.asc --detach-sign bin/provisioner-{{.GOOS}}-{{.GOARCH}}.sha256
      - cmd: gpg --batch --yes --armor --output bin/provisioner-{{.GOOS}}-{{.GOARCH}}.asc --detach-sign bin/provisioner-{{.GOOS}}-{{.GOARCH}}

  test:
    cmds:
      - task: "mocks"
      - task: "test:unit"

  test:unit:
    deps:
      - "generate"
    cmds:
      # Using go-testreport v0.3.2
      - "go install github.com/becheran/go-testreport@90efc1ce13c872f23d6bc8a069527c26288b8f9c"
      - "go test -race -cover -json -tags='!integration' ./internal/... ./pkg/... ./cmd/... | go-testreport -output unit-test-report.md -vars 'Title:Unit Test Report'"

  test:unit:verbose:
    internal: true
    desc: "Run unit tests with verbose console output"
    deps:
      - "generate"
    cmds:
      - "go test -race -cover -tags='!integration' ./internal/... ./pkg/... ./cmd/..."

  test:coverage:
    cmds:
      - "go install github.com/vladopajic/go-test-coverage/v2@7003e902e787e60375e1ce3ae5b85b19313dbff2"
      - "go test -race -cover -json -tags='!integration' ./internal/... ./pkg/... ./cmd/... -coverprofile=./cover.out -covermode=atomic -coverpkg=./..."
      - "go-test-coverage --config=./.testcoverage.yml"

  test:integration:
    desc: "Run integration tests (includes cluster_test.go)"
    deps:
      - "generate"
    cmds:
      # Using go-testreport v0.3.2
      - "go install github.com/becheran/go-testreport@90efc1ce13c872f23d6bc8a069527c26288b8f9c"
      - "go test -race -cover -json -tags='integration' ./internal/... ./pkg/... ./cmd/... | go-testreport -output integration-test-report.md -vars 'Title:Integration Test Report'"

  run:
    deps:
      - "run:provisioner"

  run:provisioner:
    deps:
      - "build"
    cmds:
      - "bin/provisioner-{{OS}}-{{ARCH}}{{exeExt}} {{.CLI_ARGS}}"

  run:provisioner:skipdl:
    deps:
      - "build"
    env:
      _LOG_LEVEL: "Debug"
    cmds:
      - "bin/provisioner-{{OS}}-{{ARCH}}{{exeExt}} {{.CLI_ARGS}}"

  install:go:
    deps:
      - "install:go:linux"

  install:go:linux:
    internal: true
    status:
      - "command -v go"
      - "command -v dlv"
    platforms:
      - "linux/amd64"
      - "linux/arm64"
    cmds:
      - "curl -sSLO https://go.dev/dl/go{{.GO_VERSION}}.{{OS}}-{{ARCH}}.tar.gz"
      - "sudo mkdir -p /usr/local/go"
      - "sudo tar -C /usr/local -xzf go{{.GO_VERSION}}.{{OS}}-{{ARCH}}.tar.gz"
      - "rm -f go{{.GO_VERSION}}.{{OS}}-{{ARCH}}.tar.gz"
      - "echo 'PATH=\"${PATH}:/usr/local/go/bin:$HOME/go/bin\"' | sudo tee /etc/profile.d/go.sh >/dev/null 2>&1"
      - "source /etc/profile.d/go.sh"
      - "source /etc/profile.d/go.sh && go install github.com/go-delve/delve/cmd/dlv@latest"
    generates:
      - "/usr/local/go/**"

  mocks:
    cmds:
      - go install github.com/golang/mock/mockgen@v1.6.0
      # Generate mocks in the package it belongs. Note these generated mock files are not checked in.
      - mockgen -source=pkg/security/principal/interface.go -self_package golang.hedera.com/solo-provisioner/pkg/security/principal -package principal > pkg/security/principal/mocks_generated.go
      - mockgen -source=pkg/fsx/interface.go -self_package golang.hedera.com/solo-provisioner/pkg/fsx -package fsx > pkg/fsx/mocks_generated.go
      - mockgen -source=pkg/software/interface.go -self_package golang.hedera.com/solo-provisioner/pkg/software -package software> pkg/software/mocks_generated.go

  # Remote debug tasks for Docker container debugging
  debug:container:
    desc: "Setup debug environment and show available debug commands"
    deps:
      - "debug:container:setup"
    cmds:
      - |
        echo "ðŸ› Debug environment ready!"
        echo ""
        echo "Available debug commands:"
        echo "  task debug:container:test -- [package]   # Debug tests (package required)"
        echo "  task debug:container:app -- [args...]    # Debug provisioner application"
        echo "  task debug:container:stop                # Stop debug container"
        echo ""

  debug:container:setup:
    desc: "Setup Docker container for remote debugging"
    dir: build
    cmds:
      - "./debug-setup.sh"

  debug:container:test:
    desc: "Start remote test debug server in Docker container (specify package with -- ./pkg/name)"
    deps:
      - "debug:container:setup"
    dir: build
    cmds:
      - "./debug-run.sh test {{.CLI_ARGS}}"

  debug:container:app:
    desc: "Start remote application debug server in Docker container (pass args with -- after command)"
    deps:
      - "debug:container:setup"
    dir: build
    cmds:
      - "./debug-run.sh app {{.CLI_ARGS}}"

  debug:container:stop:
    desc: "Stop remote debug container"
    cmds:
      - "docker stop solo-provisioner-debug 2>/dev/null || true"

  # VM Debugging Tasks
  vm:debug:
    desc: "Show available VM debug commands"
    cmds:
      - |
        echo "ðŸ› VM Debug environment ready!"
        echo ""
        echo "Available debug commands:"
        echo "  task debug:vm:test -- [package]   # Debug tests on the VM (package required)"
        echo "  task debug:vm:app -- [args...]    # Debug provisioner application on the VM"
        echo ""

  vm:debug:test:
    desc: "Start remote test debug server on the VM (specify package with -- ./pkg/name)"
    dir: scripts
    deps:
      - "vm:start"
    cmds:
      - "./debug-vm-run.sh test {{.CLI_ARGS}}"

  vm:debug:app:
    desc: "Start remote application debug server on the VM (pass args with -- after command)"
    dir: scripts
    deps:
      - "vm:start"
    cmds:
      - "./debug-vm-run.sh app {{.CLI_ARGS}}"

  vm:ip:
    cmds:
      - "{{.GET_VM_IP}} echo $(get_vm_ip)"

  # VM Management Tasks
  vm:install:
    desc: "Install UTM and rsync if not already installed"
    cmds:
      - |
        if ! command -v brew >/dev/null 2>&1; then
          echo "Error: Homebrew is required to install UTM and rsync"
          echo "Please install Homebrew first: https://brew.sh"
          exit 1
        fi
        
        if ! command -v utmctl >/dev/null 2>&1; then
          echo "Installing UTM via Homebrew..."
          brew install --cask utm
        else
          echo "UTM is already installed"
        fi
        
        if ! command -v rsync >/dev/null 2>&1; then
          echo "Installing rsync via Homebrew..."
          brew install rsync
        else
          echo "rsync is already installed"
        fi

  vm:setup:
    desc: "Download and setup the pre-built golden VM image"
    deps:
      - vm:install
    cmds:
      - task: vm:download:golden

  vm:download:golden:
    desc: "Download pre-built golden VM image from URL"
    cmds:
      - |
        echo "Checking if golden VM already exists..."

        # Check if the golden VM already exists
        if utmctl status "{{.VM_GOLDEN_NAME}}" >/dev/null 2>&1; then
          echo "âœ“ Golden VM already exists, skipping download."
          exit 0
        fi

        echo "Golden VM not found, downloading from {{.VM_GOLDEN_IMAGE_URL}}..."

        # Create temporary directory for download
        TEMP_DIR=$(mktemp -d)
        echo "Downloading to temporary directory: $TEMP_DIR"

        # Download the golden image
        if ! curl -fL -o "$TEMP_DIR/golden-image.utm" "{{.VM_GOLDEN_IMAGE_URL}}"; then
          echo "âŒ Failed to download the golden VM image from {{.VM_GOLDEN_IMAGE_URL}}"
          echo "Please check the URL and try again or download the image manually and import it manually."
          rm -rf "$TEMP_DIR"
          exit 0
        fi

        # Import the VM into UTM
        echo "Importing VM into UTM..."
        open -a UTM
        sleep 5

        # Copy the VM to UTM directory and rename
        cp -r "$TEMP_DIR/golden-image.utm" "{{.UTM_VMS_DIR}}/{{.VM_GOLDEN_NAME}}.utm"

        # Clean up
        rm -rf "$TEMP_DIR"

        echo "âœ“ Golden VM downloaded and imported successfully!"

  vm:reset:
    desc: "Clone the golden VM to create a working instance with passwordless SSH"
    deps:
      - vm:setup
    cmds:
      - |
        # Generate SSH key if it doesn't exist
        if [ ! -f "{{.SSH_PRIVATE_KEY}}" ]; then
          echo "Generating SSH key for VM access..."
          mkdir -p .ssh
          ssh-keygen -t rsa -b 2048 -f {{.SSH_PRIVATE_KEY}} -N ""
          echo "âœ“ SSH key generated at {{.SSH_PRIVATE_KEY}}"
        fi

        echo "Cloning golden VM to working instance..."

        # Check if golden VM exists
        if ! utmctl status "{{.VM_GOLDEN_NAME}}" >/dev/null 2>&1; then
          echo "Error: Golden VM '{{.VM_GOLDEN_NAME}}' not found. Run 'task vm:setup' first."
          echo "If you have downloaded the golden VM image manually, please import it manually."
          exit 1
        fi

        # Stop the golden VM if it's running (required for cloning)
        echo "Ensuring golden VM is stopped for cloning..."
        utmctl stop "{{.VM_GOLDEN_NAME}}" 2>/dev/null || true
        sleep 2

        # Stop and delete existing working VM if it exists
        if utmctl status "{{.VM_NAME}}" >/dev/null 2>&1; then
          echo "Stopping and removing existing working VM..."
          utmctl stop "{{.VM_NAME}}" 2>/dev/null || true
          sleep 2
          utmctl delete "{{.VM_NAME}}" 2>/dev/null || true
          sleep 1
        fi

        # Clone the golden VM
        echo "Cloning '{{.VM_GOLDEN_NAME}}' to '{{.VM_NAME}}'..."
        utmctl clone "{{.VM_GOLDEN_NAME}}" --name "{{.VM_NAME}}"

        echo "âœ“ VM cloned. Now starting it for initial configuration..."
      - task: vm:start
      - task: vm:configure
      - cmd: echo "âœ“ VM reset and configured successfully."

  vm:start:
    desc: "Start the working VM instance"
    deps:
      - vm:ensure-exists
    cmds:
      - utmctl start --hide "{{.VM_NAME}}"
      - |
        echo "Waiting for VM to boot (checking every 5 seconds)..."

        # Poll for VM to be ready with timeout
        MAX_ATTEMPTS=24  # 24 * 5 seconds = 2 minutes max wait
        ATTEMPT=0
        
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          ATTEMPT=$((ATTEMPT + 1))

          # Check if VM is running
          if utmctl status "{{.VM_NAME}}" >/dev/null 2>&1; then
            echo "âœ“ VM is running, checking if network is ready..."

            VM_IP=$({{.GET_VM_IP}} get_vm_ip)
            if [ -n "$VM_IP" ]; then
              echo "âœ“ VM started successfully and network is ready at $VM_IP!"
              break
            else
              echo "VM is running but network not ready yet (attempt $ATTEMPT/$MAX_ATTEMPTS)..."
            fi
          else
            echo "VM is starting... (attempt $ATTEMPT/$MAX_ATTEMPTS)"
          fi

          if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
            sleep 5
          fi
        done

        # Final check
        if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
          echo "âš ï¸  VM may not be fully ready after 2 minutes, but continuing..."
        fi
      - task: vm:ssh:port-forward

  vm:ssh:port-forward:
    desc: "Forward port 2222 to 22 on the VM for debugging purposes"
    internal: true
    cmds:
      - |
        # Check if VM is configured with SSH (check if SSH key works)
        VM_IP=$({{.GET_VM_IP}} get_vm_ip)
        if ! ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o PasswordAuthentication=no -o PubkeyAuthentication=yes {{.VM_USER}}@$VM_IP "echo 'SSH test successful'" >/dev/null 2>&1; then
          echo "SSH key authentication failed. VM may not be configured yet."
          exit 0
        fi

        echo "Setting up SSH port forwarding..."
        echo "Checking if port 2222 is available..."
        if command lsof -t -i :2222 >/dev/null 2>&1; then
          echo "Port 2222 is in use, killing existing SSH connection..."
          lsof -nP -t -iTCP:2222 -sTCP:LISTEN | xargs -r kill || true
          sleep 1
        else
          echo "âœ“ Port 2222 is available"
        fi
        # Forward port 2222 to 22 on the VM
        ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -fN -L 2222:127.0.0.1:22 {{.VM_USER}}@$VM_IP
        echo "âœ“ SSH port forwarding established on localhost:2222 for debugging purposes"

  vm:configure:
    internal: true
    desc: "Configure the VM with SSH, sudo, and mounts"
    cmds:
      - |
        echo "Configuring SSH access..."
        PUBLIC_KEY=$(cat {{.SSH_PUBLIC_KEY}})
        # This command is complex because it needs to run as the non-root user 'provisioner'
        # to ensure the authorized_keys file has the correct ownership and permissions.
        utmctl exec "{{.VM_NAME}}" --cmd /bin/su -l {{.VM_USER}} -c "mkdir -p ~/.ssh && chmod 700 ~/.ssh && echo '$PUBLIC_KEY' >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys && echo 'âœ“ SSH key configured for user {{.VM_USER}}'"
        utmctl exec "{{.VM_NAME}}" --cmd /bin/sh -c "mkdir -p /root/.ssh && chmod 700 /root/.ssh && echo '$PUBLIC_KEY' >> /root/.ssh/authorized_keys && chmod 600 /root/.ssh/authorized_keys && echo 'âœ“ SSH key configured for user root'"
      - |
        echo "Configuring SSH daemon to allow root login with keys..."
        utmctl exec "{{.VM_NAME}}" --cmd /bin/sh -c "sed -i 's/#PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config && sed -i 's/#PubkeyAuthentication.*/PubkeyAuthentication yes/' /etc/ssh/sshd_config && sed -i 's/#AuthorizedKeysFile.*/AuthorizedKeysFile .ssh\/authorized_keys/' /etc/ssh/sshd_config && systemctl restart sshd && echo 'âœ“ SSH daemon configured for root login with keys'"
      - |
        echo "Mounting shared directory..."
        utmctl exec "{{.VM_NAME}}" --cmd /bin/sh -c "mkdir -p /mnt/solo-provisioner && echo 'share   /mnt/solo-provisioner   9p  trans=virtio,version=9p2000.L,rw,nofail 0   0' | tee -a /etc/fstab && mount -a && chown -R {{.VM_USER}}:{{.VM_USER}} /mnt/solo-provisioner && echo 'âœ“ Shared directory mounted at /mnt/solo-provisioner'"
      - |
        VM_IP=$({{.GET_VM_IP}} get_vm_ip)
        echo "Installing development tools (Git, Task, Go, Delve, rsync) via SSH at $VM_IP..."

        ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@$VM_IP "
          set -e
          echo 'Installing sudo...'
          apt-get update -qq
          apt-get install -y sudo

          echo 'Configuring passwordless sudo for user {{.VM_USER}}...'
          echo '{{.VM_USER}} ALL=(ALL) NOPASSWD: ALL' > /etc/sudoers.d/{{.VM_USER}}
          chmod 440 /etc/sudoers.d/{{.VM_USER}}
        "

        ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{.VM_USER}}@$VM_IP "
          set -e
          echo 'Installing git, curl, rsync, and build tools...'
          sudo apt-get update -qq
          sudo apt-get install -y git curl rsync build-essential gcc libc6-dev

          # Install Task
          if ! command -v task >/dev/null 2>&1; then
            echo 'Installing Task...'
            curl -1sLf 'https://dl.cloudsmith.io/public/task/task/setup.deb.sh' | sudo -E bash
            sudo apt-get update -qq
            sudo apt-get install -y task
          else
            echo 'Task already installed, skipping...'
          fi

          cd /mnt/solo-provisioner
          task install:go

          echo 'âœ“ Development tools installed successfully!'
        "

  vm:ensure-exists:
    desc: "Ensure the working VM exists, creating it if necessary"
    internal: true
    cmds:
      - echo "VM '{{.VM_NAME}}' not found, creating it from golden image..."
      - task: vm:reset
    status:
      - utmctl status "{{.VM_NAME}}" >/dev/null 2>&1

  vm:stop:
    desc: "Stop the working VM instance"
    cmds:
      - |
        echo "Stopping VM '{{.VM_NAME}}'..."

        if utmctl status "{{.VM_NAME}}" >/dev/null 2>&1; then
          utmctl stop "{{.VM_NAME}}"
          echo "âœ“ VM stopped successfully!"
        else
          echo "VM '{{.VM_NAME}}' not found or already stopped."
        fi

  vm:ssh:
    desc: "SSH into the running VM"
    silent: true
    interactive: true
    deps:
      - "vm:start"
    cmds:
      - |
        VM_IP=$({{.GET_VM_IP}} get_vm_ip)

        echo "Connecting to VM at $VM_IP..."
        env -i HOME="$HOME" USER="$USER" TERM="${TERM:-xterm}" \
        ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -t {{.VM_USER}}@$VM_IP "cd /mnt/solo-provisioner 2>/dev/null || true; exec \$SHELL -l"

  vm:test:unit:
    desc: "Run all unit tests in a UTM VM (useful for testing system-level functionality)"
    deps:
      - "vm:start"
    cmds:
      - cmd: |
          VM_IP=$({{.GET_VM_IP}} get_vm_ip)

          echo "Running unit tests with verbose output in UTM VM at $VM_IP..."

          # Check if VM is accessible
          if ! ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{.VM_USER}}@$VM_IP "echo 'VM is accessible'" 2>/dev/null; then
            echo "Error: Cannot connect to VM at $VM_IP. Please ensure the VM is running with 'task vm:start'."
            exit 1
          fi

          # Install dependencies and run tests on the VM with verbose output
          ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{.VM_USER}}@$VM_IP "
            source /etc/profile.d/go.sh 2>/dev/null || true
            cd /mnt/solo-provisioner && sudo -E PATH=\"\$PATH\" task test:unit
          "

  vm:status:
    desc: "Show status of all VMs"
    cmds:
      - |
        echo "VM Status:"
        echo "=========="
        utmctl list 2>/dev/null || echo "UTM not available or no VMs found"

  vm:clean:
    desc: "Stop and delete the working VM instance"
    cmds:
      - task: vm:stop
      - |
        echo "Deleting working VM '{{.VM_NAME}}'..."

        if utmctl status "{{.VM_NAME}}" >/dev/null 2>&1; then
          utmctl delete "{{.VM_NAME}}"
          echo "âœ“ Working VM deleted successfully!"
        else
          echo "Working VM not found or already deleted."
        fi

  vm:recreate:golden:
    desc: "Re-download the golden VM image"
    cmds:
      - task: vm:delete:golden
      - task: vm:setup

  vm:delete:golden:
    desc: "Delete the golden VM"
    cmds:
      - |
        echo "Deleting golden VM..."

        if utmctl status "{{.VM_GOLDEN_NAME}}" >/dev/null 2>&1; then
          echo "Found golden VM, deleting..."
          utmctl stop "{{.VM_GOLDEN_NAME}}" 2>/dev/null || true
          sleep 2
          utmctl delete "{{.VM_GOLDEN_NAME}}"
          echo "âœ“ Golden VM deleted successfully!"
        else
          echo "Golden VM not found or already deleted."
        fi
