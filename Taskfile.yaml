# SPDX-License-Identifier: Apache-2.0

version: 3
silent: false
output: prefixed
vars:
  OS: [ linux ]
  ARCH: [ amd64, arm64 ]
  GO_VERSION: 1.25.2
  LDFLAGS: "-w -s"
  # VM configuration
  VM_OS_TYPE: '{{.VM_OS_TYPE | default "debian"}}'  # Options: debian, ubuntu
  VM_NAME: "solo-weaver-{{.VM_OS_TYPE}}"
  VM_GOLDEN_NAME: "solo-weaver-{{.VM_OS_TYPE}}-golden"
  # Set this to the actual URL or local path of your golden image (e.g., "https://storage.example.com/golden-image.utm" or "/path/to/golden-image.utm")
  # For Debian: Set your Debian golden image URL
  # For Ubuntu: Set your Ubuntu 22.04 golden image URL
  VM_GOLDEN_IMAGE_URL_DEBIAN: '{{.VM_GOLDEN_IMAGE_URL_DEBIAN | default "https://storage.googleapis.com/solo-weaver/solo-weaver-debian-golden.utm.tar.gz" }}'
  VM_GOLDEN_IMAGE_URL_UBUNTU: '{{.VM_GOLDEN_IMAGE_URL_UBUNTU | default "https://storage.googleapis.com/solo-weaver/solo-weaver-ubuntu-golden.utm.tar.gz" }}'
  VM_USER: "provisioner"
  SSH_PRIVATE_KEY: "{{.PWD}}/.ssh/id_rsa_vm"
  SSH_PUBLIC_KEY: "{{.SSH_PRIVATE_KEY}}.pub"
  UTM_VMS_DIR: "{{.HOME}}/Library/Containers/com.utmapp.UTM/Data/Documents"
  GET_VM_IP: |
    get_vm_ip() {
    utmctl ip-address "{{.VM_NAME}}" 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1
    }

tasks:
  clean:
    cmds:
      - "rm -rf bin"
      - "rm -f unit-test-report.md"
      - "mkdir -p bin"
      - "go clean -cache -testcache"
  
  vendor:
    cmds:
      - "go mod vendor"
  
  lint:
    cmds:
      - "go fmt -x ./..."
  
  lint:check:
    cmds:
      - "R=$(go fmt ./...) && if [[ -n \"$R\" ]]; then echo \"The following files require formatting:\"; echo \"$R\"; exit 1; fi"
  
  license:check:
    desc: "Check if all source files have SPDX license headers"
    dir: scripts
    cmds:
      - "./license-header.sh check"
  
  license:add:
    desc: "Add SPDX license headers to source files that are missing them"
    dir: scripts
    cmds:
      - "./license-header.sh add"
  
  license:
    desc: "Alias for license:add - Add SPDX license headers to source files"
    cmds:
      - task: license:add
  
  build:
    deps:
      - "vendor"
    cmds:
      - task: "clean"
      - task: "generate"
      - task: "build:weaver:all"
    sources:
      - "**/*.go"
    generates:
      - "bin/weaver-linux-*"
      - "bin/weaver-darwin-*"
  
  hash:
    deps:
      - "build"
    cmds:
      - task: "hash:weaver:all"
    sources:
      - "bin/weaver-linux-*"
      - "bin/weaver-darwin-*"
    generates:
      - "bin/*.sha256"
  
  sign:
    deps:
      - "build"
    cmds:
      - task: "sign:weaver:all"
  
  build:image:
    deps:
      - task: "hash"
    cmds:
      - "docker build -t solo-weaver ."
  
  generate:
    cmds:
      - "go generate ./..."
  
  build:weaver:all:
    desc: "Build the binary for all configured operating systems and architectures"
    cmds:
      - task: build:weaver:all:os
  
  build:weaver:all:os:
    internal: true
    desc: "Build the binary for all configured operating systems"
    cmds:
      - for:
          var: OS
        task: build:weaver:all:arch
        vars:
          GOOS: "{{.ITEM}}"
  
  build:weaver:all:arch:
    internal: true
    desc: "Build the binary for all configured architectures"
    cmds:
      - for:
          var: ARCH
        task: build:weaver
        vars:
          GOOS: "{{.GOOS}}"
          GOARCH: "{{.ITEM}}"
  
  build:weaver:
    desc: "Build the binary for the specified operating system and architecture"
    env:
      GOOS: "{{coalesce .GOOS OS}}"
      GOARCH: "{{coalesce .GOARCH ARCH}}"
    cmds:
      - cmd: go build -ldflags='{{.LDFLAGS}}' -trimpath -o bin/weaver-{{coalesce .GOOS OS}}-{{coalesce .GOARCH ARCH}} ./cmd/weaver
      - cmd: chmod +x bin/weaver-{{coalesce .GOOS OS}}-{{coalesce .GOARCH ARCH}}
  
  hash:weaver:all:
    desc: "Hash the binary binaries for all configured operating systems and architectures"
    cmds:
      - task: hash:weaver:all:os
  
  hash:weaver:all:os:
    internal: true
    desc: "Hash the binary binaries for all configured operating systems"
    cmds:
      - for:
          var: OS
        task: hash:weaver:all:arch
        vars:
          GOOS: "{{.ITEM}}"
  
  hash:weaver:all:arch:
    internal: true
    desc: "Hash the binary binaries for all configured architectures"
    cmds:
      - for:
          var: ARCH
        task: hash:weaver
        vars:
          GOOS: "{{.GOOS}}"
          GOARCH: "{{.ITEM}}"
  
  hash:weaver:
    internal: true
    desc: "Hash the binary binaries for the specified operating system and architecture"
    dir: bin
    cmds:
      - cmd: sha256sum weaver-{{.GOOS}}-{{.GOARCH}} > weaver-{{.GOOS}}-{{.GOARCH}}.sha256
  
  sign:weaver:all:
    desc: "Sign the binary binaries for all configured operating systems and architectures"
    cmds:
      - task: sign:weaver:all:os
  
  sign:weaver:all:os:
    internal: true
    desc: "Sign the binary binaries for all configured operating systems"
    cmds:
      - for:
          var: OS
        task: sign:weaver:all:arch
        vars:
          GOOS: "{{.ITEM}}"
  
  sign:weaver:all:arch:
    internal: true
    desc: "Sign the binary binaries for all configured architectures"
    cmds:
      - for:
          var: ARCH
        task: sign:weaver
        vars:
          GOOS: "{{.GOOS}}"
          GOARCH: "{{.ITEM}}"
  
  sign:weaver:
    internal: true
    desc: "Sign the binary binaries for the specified operating system and architecture"
    env:
      GOOS: "{{coalesce .GOOS OS}}"
      GOARCH: "{{coalesce .GOARCH ARCH}}"
    cmds:
      - task: hash:weaver
        vars:
          GOOS: "{{.GOOS}}"
          GOARCH: "{{.GOARCH}}"
      - cmd: gpg --batch --yes --armor --output bin/weaver-{{.GOOS}}-{{.GOARCH}}.sha256.asc --detach-sign bin/weaver-{{.GOOS}}-{{.GOARCH}}.sha256
      - cmd: gpg --batch --yes --armor --output bin/weaver-{{.GOOS}}-{{.GOARCH}}.asc --detach-sign bin/weaver-{{.GOOS}}-{{.GOARCH}}
  
  test:
    cmds:
      - task: "test:unit"
  
  test:unit:
    deps:
      - "generate"
      - "mocks"
    cmds:
      # Using go-testreport v0.3.2
      - "go install github.com/becheran/go-testreport@90efc1ce13c872f23d6bc8a069527c26288b8f9c"
      - "go test -race -cover -json -tags='!integration' ./internal/... ./pkg/... ./cmd/... | go-testreport -output unit-test-report.md -vars 'Title:Unit Test Report'"
  
  test:unit:verbose:
    desc: "Run unit tests with verbose console output"
    deps:
      - "generate"
      - "mocks"
    cmds:
      - "go test -v -race -cover -tags='!integration' ./internal/... ./pkg/... ./cmd/..."
  
  test:integration:verbose:
    desc: "Run integration tests with verbose console output. Use TEST_NAME to run a specific test, e.g., task test:integration:verbose TEST_NAME='^Test_StepKubeadm_Fresh_Integration$'"
    cmds:
      - |
        set +e  # Don't exit on error
        start=$(date +%s)
        
        # run tests
        {{if .TEST_NAME}}
        echo "Running integration test '{{.TEST_NAME}}'..."
        go test -p 1 -v -tags='integration' -run {{.TEST_NAME}} ./internal/... ./pkg/... ./cmd/... -timeout 60m
        {{else}}
        go test -p 1 -v -race -cover -tags='integration' ./internal/... ./pkg/... ./cmd/... -timeout 60m
        {{end}}
        status=$?
        
        end=$(date +%s)
        elapsed=$(( end - start ))
        
        hrs=$(( elapsed / 3600 ))
        mins=$(( (elapsed % 3600) / 60 ))
        secs=$(( elapsed % 60 ))
        
        {{if .TEST_NAME}}
        printf "\n=== Integration test '{{.TEST_NAME}}' finished in %02d:%02d:%02d (status %d) ===\n" \
          "$hrs" "$mins" "$secs" "$status"
        {{else}}
        printf "\n=== Integration tests finished in %02d:%02d:%02d (status %d) ===\n" \
          "$hrs" "$mins" "$secs" "$status"
        {{end}}
        
        exit $status
  
  test:coverage:
    desc: "Run test coverage analysis. Use TEST_PATHS and TEST_REGEX to filter tests. For example: task test:coverage TEST_PATHS=./pkg/software/..."
    vars:
      TEST_PATHS: '{{.TEST_PATHS | default "./internal/... ./pkg/... ./cmd/..."}}'
      TEST_REGEX: '{{.TEST_REGEX | default "."}}'
    cmds:
      - "go install github.com/vladopajic/go-test-coverage/v2@7003e902e787e60375e1ce3ae5b85b19313dbff2"
      - "go test -p 1 -tags='integration' -race -cover -json {{.TEST_PATHS}} -run '{{.TEST_REGEX}}' -coverprofile=./cover.out -covermode=atomic -coverpkg=./... -timeout 60m"
      - "go-test-coverage --config=./.testcoverage.yml"
  
  test:integration:
    desc: "Run integration tests (includes cluster_test.go)"
    deps:
      - "generate"
    cmds:
      # Using go-testreport v0.3.2
      - "go install github.com/becheran/go-testreport@90efc1ce13c872f23d6bc8a069527c26288b8f9c"
      - "go test -p 1 -race -cover -json -tags='integration' ./internal/... ./pkg/... ./cmd/... -timeout 60m > integration-test.json"
      - "go-testreport -input integration-test.json -output integration-test-report.md -vars 'Title:Integration Test Report'"
  
  run:
    deps:
      - "run:weaver"
  
  run:weaver:
    deps:
      - "build"
    cmds:
      - "bin/weaver-{{OS}}-{{ARCH}}{{exeExt}} {{.CLI_ARGS}}"
  
  run:weaver:skipdl:
    deps:
      - "build"
    env:
      _LOG_LEVEL: "Debug"
    cmds:
      - "bin/weaver-{{OS}}-{{ARCH}}{{exeExt}} {{.CLI_ARGS}}"
  
  install:go:
    deps:
      - "install:go:linux"
  
  install:go:linux:
    internal: true
    status:
      - "command -v go"
      - "command -v dlv"
    platforms:
      - "linux/amd64"
      - "linux/arm64"
    cmds:
      - "curl -sSLO https://go.dev/dl/go{{.GO_VERSION}}.{{OS}}-{{ARCH}}.tar.gz"
      - "sudo mkdir -p /usr/local/go"
      - "sudo tar -C /usr/local -xzf go{{.GO_VERSION}}.{{OS}}-{{ARCH}}.tar.gz"
      - "rm -f go{{.GO_VERSION}}.{{OS}}-{{ARCH}}.tar.gz"
      - "echo 'PATH=\"${PATH}:/usr/local/go/bin:$HOME/go/bin\"' | sudo tee /etc/profile.d/go.sh >/dev/null 2>&1"
      - "source /etc/profile.d/go.sh"
      - "source /etc/profile.d/go.sh && go install github.com/go-delve/delve/cmd/dlv@latest"
      # Set the Go toolchain to auto-upgrade to the latest version due to https://github.com/golang/go/issues/75031
      - "/usr/local/go/bin/go env -w GOTOOLCHAIN=go1.25.2+auto"
      - "sudo /usr/local/go/bin/go env -w GOTOOLCHAIN=go1.25.2+auto"
    generates:
      - "/usr/local/go/**"
  
  mocks:
    cmds:
      - go install github.com/golang/mock/mockgen@v1.6.0
      # Generate mocks in the package it belongs. Note these generated mock files are not checked in.
      - mockgen -source=pkg/security/principal/interface.go -self_package github.com/hashgraph/solo-weaver/pkg/security/principal -package principal > pkg/security/principal/mocks_generated.go
      - mockgen -source=pkg/fsx/interface.go -self_package github.com/hashgraph/solo-weaver/pkg/fsx -package fsx > pkg/fsx/mocks_generated.go
      - mockgen -source=pkg/software/interface.go -self_package github.com/hashgraph/solo-weaver/pkg/software -package software> pkg/software/mocks_generated.go
      - mockgen -source=pkg/kernel/interface.go -self_package github.com/hashgraph/solo-weaver/pkg/kernel -package kernel > pkg/kernel/mocks_generated.go
  
  # Remote debug tasks for Docker container debugging
  debug:container:
    desc: "Setup debug environment and show available debug commands"
    deps:
      - "debug:container:setup"
    cmds:
      - |
        echo "üêõ Debug environment ready!"
        echo ""
        echo "Available debug commands:"
        echo "  task debug:container:test -- [package]   # Debug tests (package required)"
        echo "  task debug:container:app -- [args...]    # Debug weaver application"
        echo "  task debug:container:stop                # Stop debug container"
        echo ""
  
  debug:container:setup:
    desc: "Setup Docker container for remote debugging"
    dir: build
    cmds:
      - "./debug-setup.sh"
  
  debug:container:test:
    desc: "Start remote test debug server in Docker container (specify package with -- ./pkg/name)"
    deps:
      - "debug:container:setup"
    dir: build
    cmds:
      - "./debug-run.sh test {{.CLI_ARGS}}"
  
  debug:container:app:
    desc: "Start remote application debug server in Docker container (pass args with -- after command)"
    deps:
      - "debug:container:setup"
    dir: build
    cmds:
      - "./debug-run.sh app {{.CLI_ARGS}}"
  
  debug:container:stop:
    desc: "Stop remote debug container"
    cmds:
      - "docker stop solo-weaver-debug 2>/dev/null || true"
  
  # VM Debugging Tasks
  vm:debug:
    desc: "Show available VM debug commands"
    cmds:
      - |
        echo "üêõ VM Debug environment ready!"
        echo ""
        echo "Available debug commands:"
        echo "  task debug:vm:test -- [package]   # Debug tests on the VM (package required)"
        echo "  task debug:vm:app -- [args...]    # Debug weaver application on the VM"
        echo ""
  
  vm:debug:test:
    desc: "Start remote test debug server on the VM (specify package with -- ./pkg/name)"
    dir: scripts
    deps:
      - "vm:start"
    cmds:
      - "./debug-vm-run.sh test {{.CLI_ARGS}}"
  
  vm:debug:app:
    desc: "Start remote application debug server on the VM (pass args with -- after command)"
    dir: scripts
    deps:
      - "vm:start"
    cmds:
      - "./debug-vm-run.sh app {{.CLI_ARGS}}"
  
  vm:targets:
    desc: "Show available VM OS targets and create VMs for specific OS types"
    cmds:
      - |
        echo "üéØ VM OS Targets"
        echo "================"
        echo ""
        echo "Available OS types:"
        echo "  ‚Ä¢ debian  - Debian Linux"
        echo "  ‚Ä¢ ubuntu  - Ubuntu 22.04"
        echo ""
        echo "Current VM_OS_TYPE: {{.VM_OS_TYPE}}"
        echo "Current VM_NAME: {{.VM_NAME}}"
        echo "Current VM_GOLDEN_NAME: {{.VM_GOLDEN_NAME}}"
        echo ""
        echo "Usage examples:"
        echo "  task vm:setup VM_OS_TYPE=debian      # Setup Debian VM"
        echo "  task vm:setup VM_OS_TYPE=ubuntu      # Setup Ubuntu 22.04 VM"
        echo "  task vm:start VM_OS_TYPE=debian      # Start Debian VM"
        echo "  task vm:start VM_OS_TYPE=ubuntu      # Start Ubuntu VM"
        echo "  task vm:reset VM_OS_TYPE=ubuntu      # Reset Ubuntu VM"
        echo ""
        echo "You can also set VM_OS_TYPE in your environment:"
        echo "  export VM_OS_TYPE=ubuntu"
        echo "  task vm:start"
        echo ""
        echo "To configure golden image URLs per OS type, set:"
        echo "  VM_GOLDEN_IMAGE_URL_DEBIAN=<url>"
        echo "  VM_GOLDEN_IMAGE_URL_UBUNTU=<url>"
  
  vm:ip:
    cmds:
      - "{{.GET_VM_IP}} echo $(get_vm_ip)"
  
  # VM Management Tasks
  vm:install:
    desc: "Install UTM and rsync if not already installed"
    cmds:
      - |
        if ! command -v brew >/dev/null 2>&1; then
          echo "Error: Homebrew is required to install UTM and rsync"
          echo "Please install Homebrew first: https://brew.sh"
          exit 1
        fi
        
        if ! command -v utmctl >/dev/null 2>&1; then
          echo "Installing UTM via Homebrew..."
          brew install --cask utm
        else
          echo "UTM is already installed"
        fi
        
        if ! command -v rsync >/dev/null 2>&1; then
          echo "Installing rsync via Homebrew..."
          brew install rsync
        else
          echo "rsync is already installed"
        fi
  
  vm:setup:
    desc: "Download and setup the pre-built golden VM image"
    deps:
      - vm:install
    cmds:
      - task: vm:download:golden
  
  vm:download:golden:
    desc: "Download pre-built golden VM image from URL. Use FORCE to force re-downloading, e.g., task vm:download:golden FORCE=true"
    env:
      FORCE: '{{.FORCE | default "false"}}'
    cmds:
      - |
        echo "Checking if golden VM already exists..."
        echo "VM OS Type: {{.VM_OS_TYPE}}"
        echo "VM Golden Name: {{.VM_GOLDEN_NAME}}"
        echo "UTM VMs Directory: {{.UTM_VMS_DIR}}"
        echo 'Force Download: {{ eq .FORCE "true" }}'
        
        if [ "{{.FORCE}}" = "true" ]; then
         echo "Force flag is set, re-downloading golden VM image..."
        else
          # Check if the golden VM already exists
          if utmctl status "{{.VM_GOLDEN_NAME}}" >/dev/null 2>&1; then
            echo "‚úì Golden VM already exists, skipping download."
            exit 0
          fi
        
          # if the .utm file exists in UTM_VMS_DIR, skip download
          echo "Checking UTM VMs directory for existing golden VM...: {{.UTM_VMS_DIR}}/{{.VM_GOLDEN_NAME}}.utm"
          if [ -d "{{.UTM_VMS_DIR}}/{{.VM_GOLDEN_NAME}}.utm" ] || [ -f "{{.UTM_VMS_DIR}}/{{.VM_GOLDEN_NAME}}.utm" ]; then
            echo "‚úì Golden VM already exists in UTM directory: {{.UTM_VMS_DIR}}/{{.VM_GOLDEN_NAME}}.utm"
            echo "üëâ Please restart UTM to reload VMs and set up the shared solo-weaver directory ('open -a UTM')."
            exit 1 # non zero would stop further steps
          else
            echo "‚úì No existing golden VM found, proceeding to download."
          fi
        fi
        
        # Determine which golden image URL to use based on OS type
        GOLDEN_IMAGE_URL=""
        case "{{.VM_OS_TYPE}}" in
          debian)
            GOLDEN_IMAGE_URL="{{.VM_GOLDEN_IMAGE_URL_DEBIAN}}"
            ;;
          ubuntu)
            GOLDEN_IMAGE_URL="{{.VM_GOLDEN_IMAGE_URL_UBUNTU}}"
            ;;
          *)
            echo "‚ùå Unknown VM_OS_TYPE: {{.VM_OS_TYPE}}"
            echo "Supported types: debian, ubuntu"
            exit 1
            ;;
        esac
        
        if [ -z "$GOLDEN_IMAGE_URL" ]; then
          echo "‚ùå No golden image URL configured for {{.VM_OS_TYPE}}"
          echo "Please set VM_GOLDEN_IMAGE_URL_{{.VM_OS_TYPE | upper}} or VM_GOLDEN_IMAGE_URL"
          echo "Example: VM_GOLDEN_IMAGE_URL_UBUNTU=https://example.com/ubuntu-22.04.utm"
          exit 1
        fi
        
        echo "Golden VM not found, downloading {{.VM_OS_TYPE}} image from $GOLDEN_IMAGE_URL..."
        
        # Create temporary directory for download
        TEMP_DIR=$(mktemp -d)
        
        # Clean up
        cleanup() { rm -rf "$TEMP_DIR"; }
        trap cleanup EXIT
        
        echo "Downloading to temporary directory: $TEMP_DIR"
        
        TMP_FILE="$TEMP_DIR/download.tar.gz"
        
        # Download the golden image
        if ! curl -fL -o "$TMP_FILE" "$GOLDEN_IMAGE_URL"; then
          echo "‚ùå Failed to download the golden VM image from $GOLDEN_IMAGE_URL"
          echo "Please check the URL and try again or download the image manually and import it manually."
          rm -rf "$TEMP_DIR"
          exit 0
        fi
        
        tar -xzf "$TMP_FILE" -C "$TEMP_DIR"
        UTM_PATH=$(find "$TEMP_DIR" -maxdepth 3 \( -type d -name '*.utm' -o -type f -name '*.utm' \) -print -quit || true)
        if [ -z "$UTM_PATH" ]; then
          echo "‚ùå No .utm entry found inside $GOLDEN_IMAGE_URL"
          exit 1
        fi
        
        # Normalize to a known path for the rest of the script
        mv "$UTM_PATH" "$TEMP_DIR/golden-image.utm"
        echo "‚úì Downloaded and prepared golden image at $TEMP_DIR/golden-image.utm"
        
        # Copy the VM to UTM directory and rename
        cp -r "$TEMP_DIR/golden-image.utm" "{{.UTM_VMS_DIR}}/{{.VM_GOLDEN_NAME}}.utm"
        
        echo "‚úì Golden VM downloaded successfully and placed in UTM directory: {{.UTM_VMS_DIR}}/{{.VM_GOLDEN_NAME}}.utm"
        echo "üëâ Please restart UTM to reload VMs and set up the shared solo-weaver directory ('open -a UTM')."
        exit 1 # non zero would stop further steps
  
  vm:reset:
    desc: "Clone the golden VM to create a working instance with passwordless SSH"
    deps:
      - vm:setup
      - proxy:start
    cmds:
      - |
        # Generate SSH key if it doesn't exist
        if [ ! -f "{{.SSH_PRIVATE_KEY}}" ]; then
          echo "Generating SSH key for VM access..."
          mkdir -p .ssh
          ssh-keygen -t rsa -b 2048 -f {{.SSH_PRIVATE_KEY}} -N ""
          echo "‚úì SSH key generated at {{.SSH_PRIVATE_KEY}}"
        fi
        
        echo "Cloning golden VM to working instance..."
        
        # Check if golden VM exists
        if ! utmctl status "{{.VM_GOLDEN_NAME}}" >/dev/null 2>&1; then
          echo "Error: Golden VM '{{.VM_GOLDEN_NAME}}' not found. Run 'task vm:setup' first."
          echo "If you have downloaded the golden VM image manually, please import it manually."
          exit 1
        fi
        
        # Stop the golden VM if it's running (required for cloning)
        echo "Ensuring golden VM is stopped for cloning..."
        utmctl stop "{{.VM_GOLDEN_NAME}}" 2>/dev/null || true
        sleep 2
        
        # Stop and delete existing working VM if it exists
        if utmctl status "{{.VM_NAME}}" >/dev/null 2>&1; then
          echo "Stopping and removing existing working VM..."
          utmctl stop "{{.VM_NAME}}" 2>/dev/null || true
          sleep 2
          utmctl delete "{{.VM_NAME}}" 2>/dev/null || true
          sleep 1
        fi
        
        # Clone the golden VM
        echo "Cloning '{{.VM_GOLDEN_NAME}}' to '{{.VM_NAME}}'..."
        utmctl clone "{{.VM_GOLDEN_NAME}}" --name "{{.VM_NAME}}"
        
        echo "‚úì VM cloned. Now starting it for initial configuration..."
      - task: vm:start
      - task: vm:configure:ssh
      - task: proxy:install-ca-cert
      - cmd: echo "‚úì VM reset and configured successfully with proxy support."
  
  vm:start:
    desc: "Start the working VM instance"
    deps:
      - vm:ensure-exists
    cmds:
      - utmctl start --hide "{{.VM_NAME}}"
      - |
        echo "Waiting for VM to boot (checking every 5 seconds)..."
        
        # Poll for VM to be ready with timeout
        MAX_ATTEMPTS=24  # 24 * 5 seconds = 2 minutes max wait
        ATTEMPT=0
        
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          ATTEMPT=$((ATTEMPT + 1))
        
          # Check if VM is running
          if utmctl status "{{.VM_NAME}}" >/dev/null 2>&1; then
            echo "‚úì VM is running, checking if network is ready..."
        
            VM_IP=$({{.GET_VM_IP}} get_vm_ip)
            if [ -n "$VM_IP" ]; then
              echo "‚úì VM started successfully and network is ready at $VM_IP!"
              break
            else
              echo "VM is running but network not ready yet (attempt $ATTEMPT/$MAX_ATTEMPTS)..."
            fi
          else
            echo "VM is starting... (attempt $ATTEMPT/$MAX_ATTEMPTS)"
          fi
        
          if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
            sleep 5
          fi
        done
        
        # Final check
        if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
          echo "‚ö†Ô∏è  VM may not be fully ready after 2 minutes, but continuing..."
        fi
      - task: vm:ssh:port-forward
  
  vm:ssh:port-forward:
    desc: "Forward port 2222 to 22 on the VM for debugging purposes"
    internal: true
    cmds:
      - |
        # Check if VM is configured with SSH (check if SSH key works)
        VM_IP=$({{.GET_VM_IP}} get_vm_ip)
        if ! ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o PasswordAuthentication=no -o PubkeyAuthentication=yes {{.VM_USER}}@$VM_IP "echo 'SSH test successful'" >/dev/null 2>&1; then
          echo "SSH key authentication failed. VM may not be configured yet."
          exit 0
        fi
        
        echo "Setting up SSH port forwarding..."
        echo "Checking if port 2222 is available..."
        if command lsof -t -i :2222 >/dev/null 2>&1; then
          echo "Port 2222 is in use, killing existing SSH connection..."
          lsof -nP -t -iTCP:2222 -sTCP:LISTEN | xargs -r kill || true
          sleep 1
        else
          echo "‚úì Port 2222 is available"
        fi
        # Forward port 2222 to 22 on the VM
        ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR -fN -L 2222:127.0.0.1:22 {{.VM_USER}}@$VM_IP
        echo "‚úì SSH port forwarding established on localhost:2222 for debugging purposes"
  
  vm:configure:
    internal: true
    desc: "Configure the VM with SSH, sudo, and mounts (full configuration)"
    cmds:
      - task: vm:configure:ssh
      - task: vm:configure:tools
  
  vm:configure:ssh:
    internal: true
    desc: "Configure SSH access, sudo, and mounts (runs before proxy setup)"
    cmds:
      - |
        echo "Configuring SSH access for user {{.VM_USER}}..."
        PUBLIC_KEY=$(cat {{.SSH_PUBLIC_KEY}})
        
        echo "DEBUG: Public key length: ${#PUBLIC_KEY} characters"
        echo "DEBUG: Configuring SSH keys via utmctl exec..."
        
        # Configure SSH for the provisioner user using utmctl exec
        # Create directory structure
        echo "Creating .ssh directory..."
        utmctl exec "{{.VM_NAME}}" --cmd /bin/bash -c "mkdir -p /home/{{.VM_USER}}/.ssh && chmod 700 /home/{{.VM_USER}}/.ssh"
        
        # Write the key using printf which handles special characters well
        echo "Writing authorized_keys file..."
        utmctl exec "{{.VM_NAME}}" --cmd /bin/bash -c "printf '%s\\n' \"$PUBLIC_KEY\" > /home/{{.VM_USER}}/.ssh/authorized_keys && chmod 600 /home/{{.VM_USER}}/.ssh/authorized_keys && chown -R {{.VM_USER}}:{{.VM_USER}} /home/{{.VM_USER}}/.ssh"
        
        echo "‚úì SSH key configured for user {{.VM_USER}}"
        
        # Ensure SSH service is installed and running
        echo "Ensuring SSH server is installed..."
        utmctl exec "{{.VM_NAME}}" --cmd /bin/bash -c "command -v sshd >/dev/null 2>&1 || apt-get update -qq && apt-get install -y openssh-server" 2>&1 || echo "SSH server check completed"
        
        echo "Configuring passwordless sudo for {{.VM_USER}} via utmctl (as root)..."
        utmctl exec "{{.VM_NAME}}" --cmd /bin/bash -c "echo '{{.VM_USER}} ALL=(ALL) NOPASSWD: ALL' > /etc/sudoers.d/{{.VM_USER}} && chmod 440 /etc/sudoers.d/{{.VM_USER}} && echo '‚úì Passwordless sudo configured for {{.VM_USER}}'" 2>&1
        
        echo "Ensuring SSH service is enabled and running..."
        utmctl exec "{{.VM_NAME}}" --cmd /bin/bash -c "systemctl enable ssh 2>/dev/null || systemctl enable sshd 2>/dev/null || true" 2>&1
        utmctl exec "{{.VM_NAME}}" --cmd /bin/bash -c "systemctl start ssh 2>/dev/null || systemctl start sshd 2>/dev/null || service ssh start 2>/dev/null || service sshd start 2>/dev/null || /etc/init.d/ssh start 2>/dev/null || true" 2>&1
      
      - |
        echo "Waiting for SSH service to be ready..."
        VM_IP=$({{.GET_VM_IP}} get_vm_ip)
        
        if [ -z "$VM_IP" ]; then
          echo "‚ùå Could not get VM IP address. VM may not have network configured."
          exit 1
        fi
        
        echo "VM IP: $VM_IP"
        echo "Attempting SSH connection to {{.VM_USER}}@$VM_IP..."
        
        MAX_SSH_ATTEMPTS=10
        SSH_ATTEMPT=0
        while [ $SSH_ATTEMPT -lt $MAX_SSH_ATTEMPTS ]; do
          SSH_ATTEMPT=$((SSH_ATTEMPT + 1))
        
          echo -n "Attempt $SSH_ATTEMPT/$MAX_SSH_ATTEMPTS: "
        
          if ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=3 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o BatchMode=yes {{.VM_USER}}@$VM_IP "echo 'SSH ready'" >/dev/null 2>&1; then
            echo "‚úì SSH is ready!"
            break
          fi
        
          echo "Connection failed, retrying..."
        
          sleep 3
        done
        
        if [ $SSH_ATTEMPT -eq $MAX_SSH_ATTEMPTS ]; then
          echo ""
          echo "‚ùå SSH is not responding after $MAX_SSH_ATTEMPTS attempts"
          echo ""
          exit 1
        fi
      - |
        echo "Configuring SSH for root user and system settings..."
        VM_IP=$({{.GET_VM_IP}} get_vm_ip)
        PUBLIC_KEY=$(cat {{.SSH_PUBLIC_KEY}})
        
        # Now use SSH as provisioner with sudo to configure root and system
        # Passwordless sudo was already configured via utmctl exec
        ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{.VM_USER}}@$VM_IP "
          set -e
        
          echo 'Verifying sudo is available...'
          if ! command -v sudo >/dev/null 2>&1; then
            echo '‚ùå sudo not found. Cannot proceed with configuration.'
            exit 1
          fi
        
          echo 'Verifying passwordless sudo is configured...'
          sudo -n true 2>/dev/null || {
            echo '‚ö†Ô∏è  Passwordless sudo not working, but continuing...'
          }
        
          echo 'Creating weaver user and group with ID 2500...'
          if ! getent group weaver >/dev/null 2>&1; then
            sudo groupadd -g 2500 weaver
            echo '‚úì Created weaver group with GID 2500'
          else
            echo 'weaver group already exists'
          fi
        
          if ! id -u weaver >/dev/null 2>&1; then
            sudo useradd -u 2500 -g 2500 -m -s /bin/bash weaver
            echo '‚úì Created weaver user with UID 2500'
          else
            echo 'weaver user already exists'
          fi
        
          echo 'Configuring SSH key for root user...'
          sudo mkdir -p /root/.ssh
          sudo chmod 700 /root/.ssh
          echo \"$PUBLIC_KEY\" | sudo tee /root/.ssh/authorized_keys >/dev/null
          sudo chmod 600 /root/.ssh/authorized_keys
          echo '‚úì SSH key configured for user root'
        
          echo 'Configuring SSH daemon to allow root login with keys...'
          sudo sed -i 's/#PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config
          sudo sed -i 's/PermitRootLogin no/PermitRootLogin yes/' /etc/ssh/sshd_config
          sudo sed -i 's/#PubkeyAuthentication.*/PubkeyAuthentication yes/' /etc/ssh/sshd_config
          sudo sed -i 's/#AuthorizedKeysFile.*/AuthorizedKeysFile .ssh\/authorized_keys/' /etc/ssh/sshd_config
          sudo systemctl restart sshd || sudo systemctl restart ssh
          echo '‚úì SSH daemon configured for root login with keys'
        
          echo 'Mounting shared directory...'
          sudo mkdir -p /mnt/solo-weaver
          if ! grep -q '/mnt/solo-weaver' /etc/fstab; then
            echo 'share   /mnt/solo-weaver   9p  trans=virtio,version=9p2000.L,rw,nofail 0   0' | sudo tee -a /etc/fstab >/dev/null
          fi
          sudo mount -a || true
        
          # Try to set ownership and permissions to the VM user (best effort)
        
          echo "‚úì Shared directory mounted at /mnt/solo-weaver"
        "
  
  vm:configure:tools:
    internal: true
    desc: "Install development tools (Git, Task, Go, Delve) - runs after proxy tunnels are set up"
    cmds:
      - |
        VM_IP=$({{.GET_VM_IP}} get_vm_ip)
        echo "Installing development tools (Git, Task, Go, Delve, rsync) via SSH at $VM_IP..."
        
        ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{.VM_USER}}@$VM_IP "
          set -e
          echo 'Installing git, curl, rsync, and build tools...'
          sudo apt-get update -qq
          sudo apt-get install -y git curl rsync build-essential binutils binutils-aarch64-linux-gnu binutils-gold gcc libc6-dev
        
          # Install Task
          if ! command -v task >/dev/null 2>&1; then
            echo 'Installing Task...'
            curl -1sLf 'https://dl.cloudsmith.io/public/task/task/setup.deb.sh' | sudo -E bash
            sudo apt-get update -qq
            sudo apt-get install -y task
          else
            echo 'Task already installed, skipping...'
          fi
        
          cd /mnt/solo-weaver
          task install:go
        
          echo '‚úì Development tools installed successfully!'
        "
  
  vm:ensure-exists:
    desc: "Ensure the working VM exists, creating it if necessary"
    internal: true
    cmds:
      - echo "VM '{{.VM_NAME}}' not found, creating it from golden image..."
      - task: vm:reset
    status:
      - utmctl status "{{.VM_NAME}}" >/dev/null 2>&1
  
  vm:stop:
    desc: "Stop the working VM instance"
    cmds:
      - |
        echo "Stopping VM '{{.VM_NAME}}'..."
        
        if utmctl status "{{.VM_NAME}}" >/dev/null 2>&1; then
          utmctl stop "{{.VM_NAME}}"
          echo "‚úì VM stopped successfully!"
        else
          echo "VM '{{.VM_NAME}}' not found or already stopped."
        fi
  
  vm:ssh:
    desc: "SSH into the running VM"
    silent: true
    interactive: true
    deps:
      - "vm:start"
    cmds:
      - |
        VM_IP=$({{.GET_VM_IP}} get_vm_ip)
        
        echo "Connecting to VM at $VM_IP..."
        env -i HOME="$HOME" USER="$USER" TERM="${TERM:-xterm}" \
        ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -t {{.VM_USER}}@$VM_IP "cd /mnt/solo-weaver 2>/dev/null || true; exec \$SHELL -l"
  
  vm:test:unit:
    desc: "Run all unit tests in a UTM VM (useful for testing system-level functionality)"
    deps:
      - "vm:start"
    cmds:
      - cmd: |
          VM_IP=$({{.GET_VM_IP}} get_vm_ip)
          
          echo "Running unit tests with verbose output in UTM VM at $VM_IP..."
          
          # Check if VM is accessible
          if ! ssh -i {{.SSH_PRIVATE_KEY}} -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{.VM_USER}}@$VM_IP "echo 'VM is accessible'" 2>/dev/null; then
            echo "Error: Cannot connect to VM at $VM_IP. Please ensure the VM is running with 'task vm:start'."
            exit 1
          fi
          
          # Install dependencies and run tests on the VM with verbose output
          ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{.VM_USER}}@$VM_IP "
            source /etc/profile.d/go.sh 2>/dev/null || true
            cd /mnt/solo-weaver && sudo -E PATH=\"\$PATH\" task test:unit:verbose
          "
  
  vm:test:integration:
    desc: "Run all integration tests in a UTM VM with cache proxies (useful for testing system-level functionality). Use TEST_NAME to run a specific test, e.g., task vm:test:integration TEST_NAME='^Test_InitializeCluster_Fresh_Integration$'"
    deps:
      - vm:start
    cmds:
      - cmd: |
          VM_IP=$({{.GET_VM_IP}} get_vm_ip)
          
          echo "Running integration tests with verbose output in UTM VM at $VM_IP..."
          
          # Install dependencies and run tests on the VM with verbose output
          ssh -i {{.SSH_PRIVATE_KEY}} \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ExitOnForwardFailure=yes \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=3 \
              -R 3128:localhost:3128 \
              -R 8081:localhost:8081 \
              -R 5050:localhost:5050 \
              {{.VM_USER}}@$VM_IP "
            source /etc/profile.d/go.sh 2>/dev/null || true
            cd /mnt/solo-weaver &&
            echo 'Using cache infrastructure via SSH tunnels:' &&
            echo '  - HTTP/HTTPS proxy at localhost:3128 (Squid with SSL MITM - binaries, packages)' &&
            echo '  - Go module proxy at localhost:8081 (Go dependencies)' &&
            echo '  - Registry mirror at localhost:5050 (container images)' &&
            echo '' &&
            echo 'Verifying SSH tunnels are active...' &&
            netstat -tln | grep -E ':(3128|8081|5050)' || echo 'WARNING: Some tunnels may not be active yet' &&
            echo '' &&
            echo 'Testing proxy connectivity...' &&
            timeout 5 nc -zv localhost 3128 2>&1 && echo '‚úì Squid proxy (3128) is reachable' || echo '‚úó Squid proxy (3128) is NOT reachable' &&
            timeout 5 nc -zv localhost 8081 2>&1 && echo '‚úì Go proxy (8081) is reachable' || echo '‚úó Go proxy (8081) is NOT reachable' &&
            timeout 5 nc -zv localhost 5050 2>&1 && echo '‚úì Registry mirror (5050) is reachable' || echo '‚úó Registry mirror (5050) is NOT reachable' &&
            echo '' &&
            export HTTP_PROXY=http://localhost:3128
            export HTTPS_PROXY=http://localhost:3128
            export NO_PROXY=localhost,127.0.0.1,::1,.local,.svc,.cluster.local,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16
            export SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
            export CURL_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt
            export REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt
            export GODEBUG=http2debug=0
            export GOPROXY=http://localhost:8081,https://proxy.golang.org,direct
            export GOSUMDB=sum.golang.org
            echo 'Environment variables set:' &&
            echo '  HTTP_PROXY='\$HTTP_PROXY &&
            echo '  HTTPS_PROXY='\$HTTPS_PROXY &&
            echo '  NO_PROXY='\$NO_PROXY &&
            echo '  SSL_CERT_FILE='\$SSL_CERT_FILE &&
            echo '  GOPROXY='\$GOPROXY &&
            echo '' &&
            sudo --preserve-env=HTTP_PROXY,HTTPS_PROXY,NO_PROXY,SSL_CERT_FILE,CURL_CA_BUNDLE,REQUESTS_CA_BUNDLE,GOPROXY,GOSUMDB,GODEBUG,PATH \
              task test:integration:verbose TEST_NAME={{.TEST_NAME}}
          "
  
  vm:status:
    desc: "Show status of all VMs"
    cmds:
      - |
        echo "VM Status:"
        echo "=========="
        echo "Current VM_OS_TYPE: {{.VM_OS_TYPE}}"
        echo "Current VM_NAME: {{.VM_NAME}}"
        echo ""
        echo "All UTM VMs:"
        utmctl list 2>/dev/null || echo "UTM not available or no VMs found"
  
  vm:clean:
    desc: "Stop and delete the working VM instance"
    cmds:
      - task: vm:stop
      - |
        echo "Deleting working VM '{{.VM_NAME}}'..."
        
        if utmctl status "{{.VM_NAME}}" >/dev/null 2>&1; then
          utmctl delete "{{.VM_NAME}}"
          echo "‚úì Working VM deleted successfully!"
        else
          echo "Working VM not found or already deleted."
        fi
  
  vm:recreate:golden:
    desc: "Re-download the golden VM image"
    cmds:
      - task: vm:delete:golden
      - task: vm:setup
  
  vm:delete:golden:
    desc: "Delete the golden VM"
    cmds:
      - |
        echo "Deleting golden VM..."
        
        if utmctl status "{{.VM_GOLDEN_NAME}}" >/dev/null 2>&1; then
          echo "Found golden VM, deleting..."
          utmctl stop "{{.VM_GOLDEN_NAME}}" 2>/dev/null || true
          sleep 2
          utmctl delete "{{.VM_GOLDEN_NAME}}"
          echo "‚úì Golden VM deleted successfully!"
        else
          echo "Golden VM not found or already deleted."
        fi
  
  # =============================================================================
  # Cache Proxy Tasks - Optimize integration test performance
  # =============================================================================
  
  proxy:start:
    desc: "Start cache proxy infrastructure (HTTP/HTTPS proxy, container registry mirror, Go proxy)"
    dir: test/cache-proxy
    cmds:
      - |
        echo "Starting cache proxy infrastructure..."
        if docker-compose ps | grep -q "solo-weaver-cache-proxy.*Up"; then
          echo "Cache proxy is already running"
        else
          docker-compose up -d
          echo "Waiting for services to be ready..."
          sleep 5
          echo ""
          echo "‚úì Cache infrastructure started successfully!"
          echo ""
          echo "Services running:"
          echo "  ‚Ä¢ HTTP/HTTPS Proxy:    http://localhost:3128 (Squid with SSL MITM)"
          echo "  ‚Ä¢ Container Registry:  http://localhost:5050 (mirrors registry.k8s.io)"
          echo "  ‚Ä¢ Go Module Proxy:     http://localhost:8081"
          echo ""
          echo "To use the proxies, set these environment variables:"
          echo "  export HTTP_PROXY=http://localhost:3128"
          echo "  export HTTPS_PROXY=http://localhost:3128"
          echo "  export GOPROXY=http://localhost:8081"
          echo ""
          echo "‚ö†Ô∏è  For HTTPS caching, install the CA certificate on your VMs:"
          echo "  task proxy:install-ca-cert"
          echo ""
          echo "For CRI-O registry mirror, the registries.conf is installed during test setup."
        fi
  
  proxy:install-ca-cert:
    desc: "Install MITM proxy CA certificate in VM for HTTPS caching"
    deps:
      - proxy:start
      - vm:start
    cmds:
      - cmd: |
          VM_IP=$({{.GET_VM_IP}} get_vm_ip)
          CA_CERT_PATH="test/cache-proxy/ca-cert.pem"
          
          echo "Installing Squid MITM proxy CA certificate in VM..."
          
          # Always extract fresh CA certificate from proxy container
          # This ensures we get the correct certificate even after proxy:rebuild
          echo "Extracting CA certificate from Squid proxy container..."
          docker cp solo-weaver-cache-proxy:/etc/squid/certs/ca-cert.pem "$CA_CERT_PATH"
          echo "‚úì CA certificate extracted to $CA_CERT_PATH"
          
          # Show certificate details
          echo "Certificate details:"
          openssl x509 -in "$CA_CERT_PATH" -noout -subject -dates | head -3
          
          # Copy to VM
          echo "Copying CA certificate to VM..."
          scp -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "$CA_CERT_PATH" {{.VM_USER}}@$VM_IP:/tmp/solo-weaver-ca.crt
          
          # Install in VM
          echo "Installing certificate in VM..."
          ssh -i {{.SSH_PRIVATE_KEY}} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{.VM_USER}}@$VM_IP \
            "sudo cp /tmp/solo-weaver-ca.crt /usr/local/share/ca-certificates/solo-weaver-ca.crt && \
             sudo chmod 644 /usr/local/share/ca-certificates/solo-weaver-ca.crt && \
             sudo update-ca-certificates --fresh && \
             echo 'Verifying CA certificate was added to bundle...' && \
             if grep -q 'Solo Weaver Cache Proxy CA' /etc/ssl/certs/ca-certificates.crt; then \
               echo '‚úì CA certificate verified in bundle'; \
             else \
               echo '‚ö† Warning: CA certificate not found in bundle'; \
             fi"
          
          echo ""
          echo "‚úÖ Squid MITM CA certificate installed successfully!"
          echo ""
          echo "The VM can now use the Squid proxy for HTTPS caching with SSL interception."
          echo "Run: task vm:test:integration"
  
  proxy:rebuild:
    desc: "Rebuild and restart the cache proxy (after code changes)"
    dir: test/cache-proxy
    cmds:
      - |
        echo "Rebuilding cache proxy (forcing fresh build)..."
        
        # Remove cached CA certificate since we're regenerating it
        rm -f ca-cert.pem ca-key.pem || true
        echo "‚úì Removed cached CA certificates"
        
        docker-compose down -v || true
        docker rmi -f $(docker images -q cache-proxy-cache-proxy 2>/dev/null) 2>/dev/null || true
        docker-compose build --no-cache
        docker-compose up -d
        sleep 2
        echo ""
        echo "‚úÖ Proxy rebuilt and restarted with new CA certificate"
        echo ""
        echo "Checking status..."
        docker-compose ps
        echo ""
        echo "Recent logs:"
        docker-compose logs --tail=5
        echo ""
        echo "‚ö†Ô∏è  IMPORTANT: New CA certificate generated!"
        echo "   Run 'task proxy:install-ca-cert' to install in VM"
        echo "   Or run 'task vm:test:integration' which will install it automatically"
  
  proxy:stop:
    desc: "Stop the cache proxy server"
    dir: test/cache-proxy
    cmds:
      - docker-compose down
  
  proxy:status:
    desc: "Show cache proxy status and statistics"
    dir: test/cache-proxy
    cmds:
      - |
        echo "Cache Proxy Status:"
        echo "==================="
        docker-compose ps
        echo ""
        if docker ps | grep -q solo-weaver-cache-proxy; then
          echo "Cache sizes:"
          docker exec solo-weaver-cache-proxy du -sh /var/cache/squid 2>/dev/null | awk '{print "  HTTP/HTTPS cache (Squid): " $1}'
          docker exec solo-weaver-registry-mirror du -sh /var/lib/registry 2>/dev/null | awk '{print "  Registry: " $1}' || true
          docker exec solo-weaver-goproxy du -sh /go 2>/dev/null | awk '{print "  Go modules: " $1}' || true
        
          echo ""
          echo "Large-object cache stats (>1MB):"
          if docker exec solo-weaver-cache-proxy test -f /var/log/squid/access.log 2>/dev/null; then
            LOGCMD="docker exec solo-weaver-cache-proxy sh -c"
        
            # field 5 = bytes sent to client
            TOTAL=$($LOGCMD "awk '\$5 >= 1000000 && \$4 ~ /TCP_/ {c++} END {print c+0}' /var/log/squid/access.log" || echo 0)
            HITS=$($LOGCMD "awk '\$5 >= 1000000 && \$4 ~ /(TCP_HIT|TCP_MEM_HIT|TCP_REFRESH_HIT|TCP_REFRESH_UNMODIFIED|TCP_IMS_HIT)/ {c++} END {print c+0}' /var/log/squid/access.log" || echo 0)
            MISSES=$($LOGCMD "awk '\$5 >= 1000000 && \$4 ~ /(TCP_MISS|TCP_CLIENT_REFRESH_MISS|TCP_SWAPFAIL_MISS)/ {c++} END {print c+0}' /var/log/squid/access.log" || echo 0)
        
            echo "  Total large responses: $TOTAL"
            echo "  Large hits:   $HITS"
            echo "  Large misses: $MISSES"
        
            if [ "$TOTAL" -gt 0 ]; then
              HIT_RATE=$(echo "scale=2; ($HITS * 100) / $TOTAL" | bc)
              echo "  Large-object hit rate: ${HIT_RATE}%"
            fi
          else
            echo "  No access log yet"
          fi
        
          echo ""
          echo "Recent activity (last 10 requests):"
          docker exec solo-weaver-cache-proxy tail -10 /var/log/squid/access.log 2>/dev/null | awk '{print "  " $4 " " $7}' || echo "  No activity yet"
        
        else
          echo "Cache proxy is not running"
          echo "Start it with: task proxy:start"
        fi

