# SPDX-License-Identifier: Apache-2.0

name: "ZXC: Integration Test"
on:
  workflow_call:
    inputs:
      go-version:
        description: "Go Version:"
        type: string
        required: false
        default: "1.25.x"
      custom-job-label:
        description: "Custom Job Label:"
        type: string
        required: false
        default: "Integration Test"
      vm-os:
        description: "VM OS (debian or ubuntu):"
        type: string
        required: false
        default: "debian"

defaults:
  run:
    shell: bash

permissions:
  contents: read

jobs:
  integration-test:
    name: "${{ inputs.custom-job-label || 'Integration Test' }}"
    runs-on: ubuntu-latest
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@df199fb7be9f65074067a9eb93f12bb4c5547cf2 # v2.13.3
        with:
          egress-policy: audit

      - name: Checkout Code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Setup GoLang (Host)
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6.1.0
        with:
          go-version: ${{ inputs.go-version || '1.25.x' }}

      - name: Install Task (Host)
        uses: arduino/setup-task@b91d5d2c96a56797b48ac1e0e89220bf64044611 # v2.0.0
        with:
          version: 3.39.2
          repo-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect KVM availability
        id: kvm
        run: |
          set -euo pipefail
          if [ -e /dev/kvm ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
            echo "KVM device present: /dev/kvm"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            echo "KVM not present: /dev/kvm does not exist"
          fi

      - name: Install QEMU and dependencies
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            qemu-system-x86 \
            qemu-utils \
            cloud-image-utils \
            genisoimage \
            openssh-client \
            rsync \
            netcat-openbsd

      - name: Generate SSH key for VM access
        run: |
          set -euo pipefail
          mkdir -p .ssh
          ssh-keygen -t ed25519 -f .ssh/id_ed25519_vm -N "" -C "ci-vm-key"
          chmod 600 .ssh/id_ed25519_vm
          chmod 644 .ssh/id_ed25519_vm.pub
          echo "SSH key generated for VM access"

      - name: Download cloud image
        id: download-image
        run: |
          set -euo pipefail
          VM_OS="${{ inputs.vm-os }}"

          case "$VM_OS" in
            debian)
              IMAGE_URL="https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-genericcloud-amd64.qcow2"
              IMAGE_FILE="debian-12-cloud.qcow2"
              ;;
            ubuntu)
              IMAGE_URL="https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
              IMAGE_FILE="ubuntu-22.04-cloud.img"
              ;;
            *)
              echo "Unsupported VM OS: $VM_OS"
              exit 1
              ;;
          esac

          echo "Downloading $VM_OS cloud image..."
          wget -q --show-progress "$IMAGE_URL" -O "$IMAGE_FILE"

          echo "image_file=$IMAGE_FILE" >> "$GITHUB_OUTPUT"
          echo "vm_os=$VM_OS" >> "$GITHUB_OUTPUT"

      - name: Create cloud-init configuration
        run: |
          set -euo pipefail
          SSH_PUB_KEY=$(cat .ssh/id_ed25519_vm.pub)

          cat > meta-data <<EOF
          instance-id: ci-vm-001
          local-hostname: ci-vm
          EOF

          # IMPORTANT:
          # - Keep cloud-init simple and bring SSH up ASAP.
          # - Do NOT rely on long installs here; do those after SSH is reachable.
          cat > user-data <<EOF
          #cloud-config
          users:
            - name: provisioner
              groups: sudo
              shell: /bin/bash
              sudo: ['ALL=(ALL) NOPASSWD:ALL']
              ssh_authorized_keys:
                - $SSH_PUB_KEY

          system_info:
            default_user:
              name: provisioner

          # Create weaver user with UID/GID 2500
          bootcmd:
            - groupadd -g 2500 weaver || true
            - useradd -u 2500 -g 2500 -m -s /bin/bash weaver || true

          packages:
            - openssh-server
            - sudo
            - ca-certificates
            - curl

          runcmd:
            # Bring SSH up ASAP so CI can connect quickly
            - systemctl enable --now ssh || systemctl enable --now sshd
            - sed -i 's/^#\\?PubkeyAuthentication .*/PubkeyAuthentication yes/' /etc/ssh/sshd_config || true
            - systemctl restart ssh || systemctl restart sshd || true
          EOF

          genisoimage -output cloud-init.iso \
            -volid cidata \
            -joliet \
            -rock \
            user-data meta-data

          echo "Cloud-init configuration created"

      - name: Create VM disk overlay
        run: |
          set -euo pipefail
          IMAGE_FILE="${{ steps.download-image.outputs.image_file }}"

          BACKING_FMT="$(qemu-img info --output=json "$IMAGE_FILE" | jq -r '.format')"
          if [ -z "$BACKING_FMT" ] || [ "$BACKING_FMT" = "null" ]; then
            echo "Could not determine backing format for $IMAGE_FILE"
            qemu-img info "$IMAGE_FILE"
            exit 1
          fi

          echo "Backing image format: $BACKING_FMT"

          qemu-img create -f qcow2 -F "$BACKING_FMT" -b "$IMAGE_FILE" vm-disk.qcow2 20G
          echo "VM disk overlay created"

      - name: Start QEMU VM
        id: start-vm
        run: |
          set -euo pipefail
          KVM_AVAILABLE="${{ steps.kvm.outputs.available }}"

          if [ "$KVM_AVAILABLE" = "true" ]; then
            # We'll still verify in the wait loop if QEMU dies.
            ACCEL_OPTS="-enable-kvm -cpu host"
            echo "Attempting KVM acceleration"
          else
            ACCEL_OPTS="-accel tcg"
            echo "Using TCG (software emulation, slower)"
          fi

          # Start QEMU in background.
          # - Attach cloud-init as CD-ROM (more reliable for datasource detection).
          # - Log serial output to a file (useful for debugging).
          qemu-system-x86_64 \
            $ACCEL_OPTS \
            -m 4096 \
            -smp 2 \
            -drive file=vm-disk.qcow2,if=virtio,format=qcow2 \
            -drive file=cloud-init.iso,media=cdrom,readonly=on \
            -nographic \
            -serial file:vm-console.log \
            -netdev user,id=net0,hostfwd=tcp::2222-:22 \
            -device virtio-net-pci,netdev=net0 \
            >/dev/null 2>&1 &

          VM_PID=$!
          echo "vm_pid=$VM_PID" >> "$GITHUB_OUTPUT"
          echo "$VM_PID" > vm.pid
          echo "VM started with PID: $VM_PID"

      - name: Wait for VM to be ready
        timeout-minutes: 10
        run: |
          set -euo pipefail
          echo "Waiting for VM SSH to be ready..."

          VM_PID="$(cat vm.pid)"
          MAX_ATTEMPTS=60
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo -n "Attempt $ATTEMPT/$MAX_ATTEMPTS: "

            # Fail fast if QEMU exited
            if ! kill -0 "$VM_PID" 2>/dev/null; then
              echo "❌ QEMU process is not running anymore (PID: $VM_PID)"
              echo "=== vm-console.log (last 200 lines) ==="
              tail -200 vm-console.log || true
              exit 1
            fi

            # Quick port signal
            if nc -z localhost 2222; then
              echo -n "port 2222 open; "
            else
              echo -n "port 2222 closed; "
            fi

            if ssh -i .ssh/id_ed25519_vm \
                 -o ConnectTimeout=5 \
                 -o StrictHostKeyChecking=no \
                 -o UserKnownHostsFile=/dev/null \
                 -o BatchMode=yes \
                 -p 2222 \
                 provisioner@localhost \
                 "echo 'SSH ready'" >/dev/null 2>&1; then
              echo "✓ VM is ready!"
              exit 0
            fi

            echo "not ready yet, waiting..."
            sleep 10
          done

          echo "❌ VM failed to become ready after $MAX_ATTEMPTS attempts"
          echo "=== vm-console.log (last 200 lines) ==="
          tail -200 vm-console.log || true
          exit 1

      - name: Bootstrap VM tools (Go + task deps)
        timeout-minutes: 20
        run: |
          set -euo pipefail
          ssh -i .ssh/id_ed25519_vm \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              -p 2222 \
              provisioner@localhost << 'EOSSH'
          set -euo pipefail

          sudo cloud-init status --wait || true

          # Install deps we need for builds/tests
          sudo apt-get update
          sudo apt-get install -y git rsync build-essential binutils gcc libc6-dev

          # Install Go (explicit version)
          GO_VER="1.25.2"
          curl -sSLO "https://go.dev/dl/go${GO_VER}.linux-amd64.tar.gz"
          sudo rm -rf /usr/local/go
          sudo tar -C /usr/local -xzf "go${GO_VER}.linux-amd64.tar.gz"
          rm "go${GO_VER}.linux-amd64.tar.gz"

          echo 'export PATH=$PATH:/usr/local/go/bin:$HOME/go/bin' | sudo tee /etc/profile.d/go.sh >/dev/null
          sudo chmod +x /etc/profile.d/go.sh
          sudo ln -sf /usr/local/go/bin/go /usr/local/bin/go
          sudo ln -sf /usr/local/go/bin/gofmt /usr/local/bin/gofmt

          # Avoid surprise toolchain downloads in CI
          /usr/local/go/bin/go env -w GOTOOLCHAIN=local

          # Optional: install Task inside VM (if your Taskfile expects it there)
          if ! command -v task >/dev/null 2>&1; then
            curl -1sLf 'https://dl.cloudsmith.io/public/task/task/setup.deb.sh' | sudo -E bash
            sudo apt-get update
            sudo apt-get install -y task
          fi

          /usr/local/bin/go version
          task --version || true
          EOSSH

      - name: Sync code to VM
        run: |
          set -euo pipefail
          echo "Syncing code to VM..."

          ssh -i .ssh/id_ed25519_vm \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              -p 2222 \
              provisioner@localhost \
              "mkdir -p /home/provisioner/solo-weaver"

          rsync -az \
            -e "ssh -i .ssh/id_ed25519_vm -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=30 -o ServerAliveCountMax=10 -p 2222" \
            --exclude='.git' \
            --exclude='vendor' \
            --exclude='bin' \
            --exclude='*.log' \
            --exclude='.ssh' \
            --exclude='vm-disk.qcow2' \
            --exclude='*.iso' \
            --exclude='*.img' \
            --exclude='*.qcow2' \
            ./ \
            provisioner@localhost:/home/provisioner/solo-weaver/

          echo "✓ Code synced to VM"

      - name: Run Integration Tests in VM
        timeout-minutes: 90
        run: |
          set -euo pipefail
          echo "Running integration tests in VM..."

          ssh -i .ssh/id_ed25519_vm \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ServerAliveInterval=30 \
              -o ServerAliveCountMax=10 \
              -o TCPKeepAlive=yes \
              -p 2222 \
              provisioner@localhost << 'EOSSH'
          set -euo pipefail

          export PATH=/usr/local/go/bin:$HOME/go/bin:/usr/local/bin:$PATH
          export GOPATH=$HOME/go

          cd /home/provisioner/solo-weaver

          # Ensure mockgen available (as provisioner)
          if ! command -v mockgen >/dev/null 2>&1; then
            go install github.com/golang/mock/mockgen@v1.6.0
          fi

          # If tasks must run as root, preserve PATH/GOPATH explicitly
          sudo -E env "PATH=$PATH" "GOPATH=$GOPATH" task generate
          sudo -E env "PATH=$PATH" "GOPATH=$GOPATH" task mocks
          sudo -E env "PATH=$PATH" "GOPATH=$GOPATH" task test:integration:verbose
          EOSSH

          echo "✓ Integration tests completed"

      - name: Retrieve test results
        if: always()
        run: |
          set -euo pipefail
          echo "Retrieving test results from VM..."

          rsync -az \
            -e "ssh -i .ssh/id_ed25519_vm -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=30 -p 2222" \
            provisioner@localhost:/home/provisioner/solo-weaver/integration-test-report.md \
            ./ || echo "No integration test report found"

          rsync -az \
            -e "ssh -i .ssh/id_ed25519_vm -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=30 -p 2222" \
            provisioner@localhost:/home/provisioner/solo-weaver/integration-test.json \
            ./ || echo "No integration test JSON found"

      - name: Integration Test Report
        if: always()
        run: |
          set -euo pipefail
          if [[ -f integration-test-report.md ]]; then
            cat integration-test-report.md >> "${GITHUB_STEP_SUMMARY}"
          else
            echo "⚠️ No integration test report found" >> "${GITHUB_STEP_SUMMARY}"
          fi

      - name: Cleanup VM
        if: always()
        run: |
          set -euo pipefail
          if [ -f vm.pid ]; then
            VM_PID=$(cat vm.pid)
            echo "Stopping VM (PID: $VM_PID)..."
            kill "$VM_PID" 2>/dev/null || true
            sleep 2
            kill -9 "$VM_PID" 2>/dev/null || true
          fi

          echo "Cleaning up VM files..."
          rm -f vm-disk.qcow2 cloud-init.iso vm.pid vm-console.log
          rm -f meta-data user-data
          rm -f debian-*.qcow2 ubuntu-*.img
